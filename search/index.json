[{"content":"▶️ 前言 相信各位应该看过信科大一通关指南。其中心态篇与方法篇也介绍了许多内容，各位感觉有需要可以翻一翻。\n正文无关。各位可能会疑惑，为什么这个网站的域名是 ovideros.site 而不是 ovideros.github.io？请参考关于。\n睿信与特立在大一暑假，便要选专业。当时我因为各种专业的差别，犹豫了很久。最后发现自己排名很高，于是选择了计拔。现在回头来看，在计算机大类中，各个专业（计科、软工、AI、大数据）具体差别并不大，只要你选择的专业符合你的需求即可。\n对于软件工程专业，多谢Reina同学写了一个北京理工大学软件工程课程资料仓库，质量很高，里面也有对各个课程的评价，可以与本指南互补。\n需要注意，本攻略只是记载了我对于许多课程的主观看法以及个人心得，并不能做到客观。事实上，不同课程对于不同人都会有不同的难度，每个人都会有自己独特的方法。并不存在一种学习方法可以推之四海而皆准，适合自己的才是最好的。\n同时，作为一个应试还不错的人，下面不少内容可能都存在幸存者偏差或者片面归因。“成功者”想要写一个攻略，便会找一些理由，然而这些理由可能只是成功的推进因素，并不是决定性因素（可参考真理元素的这期视频）。同时，每个人的关键优势也不相同。这里我举一个科幻的例子—— SCP-CN-3000 - 众节点永垂不朽。\n下一段存在剧透，对此 SCP 感兴趣的或者想读一读的建议先去看看源文档）\n正文无关。我初高中阶段出于无聊，用 Kindle 联网，看过一些 SCP 的作品，感觉很有意思。进入大学以来，几乎没怎么看过。这学期考试周前一周，我打开了 SCP CN，虽然知道很早就有 CN 3000 了，不过还没看。用 2h 看完了，感到相当震撼。如果你此前没有接触过 SCP，但是对科幻相关感兴趣，推荐看一看。\n在 SCP-CN-3000 中，为了应对非物质，众人经过不断尝试，发现了一种方案——不同人根据稀金的指引，用独特的方式改变自身，达到有效特征向量，并将其广播，进而成为节点。该过程相当多样的——有利用稀金追求梦想的工匠，有放浪形骸的酿酒师，有为了拯救世界而失去心脏的情侣，有勇敢猎杀太阳的猎手\u0026hellip;\u0026hellip; 为什么这些人可以用独特的方式找到有效地特征向量呢？没人知道。异常并不会回答。但是每一个成为节点的个体，都充分发挥了自己的特质，将自身的喜好与优势坚持到底。这便是人类能够反抗异常的力量。\n回到刚刚的话题，不同人因为先天与后天的各种条件不同，都是独特的个体。所以，本文也只是记录了一种符合我个人特性的学习方式与个人心得，在我身上，它很适用。但对于不同特性的人，方法不尽相同。一味照搬我的方法，并不能让你的学习效率变高，反而有可能因为不适合，成为某种路径依赖，阻碍了真正有效的方式。\n说回“幸存者偏差”，接下来留下来的攻略，反而可能并不是成功的关键因素，而是次要因素。真正关键的因素，是隐藏在具体方法或具体路径之后的精神，是每个人特有的价值——例如积极地搜集各类信息与资源，大胆地改变过去的做法，无畏地尝试新事物，对自身特性的理解，对知识纯粹的好奇等等。许多特性在大众看来是较为少见的——例如我了解有学长不刷各类社交媒体与长短视频网站，拥有殖民火星的梦想，并以此为动力积极创业；有学长课内成绩并不优秀，但对于科研有发自内心的兴趣，对知识具有好奇心，本科阶段发了多篇顶会文章；有学长“比较俗气”地想搞钱，积极学习开发技术，去多个大厂实习，本科毕业拿到好 offer \u0026hellip;\u0026hellip;\n对于我个人而言，我可能并没有那么纯粹的特质，不过经过两年的大学生活，可能也找到了一些：\n我觉得真正理解知识是有趣的，为此会选择主动寻找资源帮助理解 我喜欢从多重视角看问题，甚至是不同学科的视角 对于难以平衡的一些事情（例如科研 vs 竞赛 vs 水综测），我会选择直接放弃不重要的 所以，下面的攻略或多或少会包含我的这些个人特质，请各位明鉴。也希望各位可以积极探索，或许可以找到一些自己的特质吧。\n大二上的顶级折磨 下面采取更新式的方法，说一说我认为大二与大一的区别。\n如果你是信科，想必感受到了大一下与大一上难度有着鸿沟。然而大二上也不简单。具体来说，我们这一届大一下平均分为 79.3，大二上平均分为 78.3 。这还是许多优秀学生选择去计算机学院，卷出来的结果。\n我们这一届的核心课程如下：\n数据结构与算法设计，5 学分 离散数学，4 学分 大学物理A II，4 学分 概率论与数理统计，3 学分 马原，3 学分 数值分析，2 学分 小学期有两门课——程序设计方法与实践，1 学分；网站开发，1 学分。\n根据课表，今年开始，5 学分的数据结构与算法设计变成了 3.5 学分的数据结构课，又拆开了。\n并且，今年小学期好像合并了网站开发与算法题两门课程。原先，这两门课各自 1 学分，现在合起来变成了 3 学分的课，不确定会如何。\n大二下稍微放松 大二下相对轻松一些，可以多选一些选修课。\n核心课程如下：\n数据库原理，3 学分 毛中特，3 学分 面向对象技术与方法，2 学分 数字逻辑，2 学分 如果你是计科的，那么就没了。计拔会多一门数据科学与大数据技术的数学基础，2 学分，这门课也是大数据专业与大数据全英班的必修课。\n💛心态篇补充 关于未来方向 进入大二，你应该逐渐明确自己的专业方向与未来路径，并知道课外应该往哪方面努力（例如多刷一些公开课提升实力，多刷算法题打 acm，多去工训楼搞机器人队，多学开发技术进大厂实习，或者进组科研实习等等）。\n因为每个人的路径并不相同，所以这方面并没有统一的答案。很多事情是个人偏好决定的。例如在计算机保研指南中，有的人倾向学校的 title，有的人倾向好城市，有的人倾向于好导师。这都没有对错，只是不同人有不同的喜好罢了。\n不过，我还是建议各位尽早尝试，这样有可能找到自己比较喜欢的方向。其实喜欢也并非一个很高的标准，只要你不讨厌每天花几个小时做这件事，并且持续几个星期，我觉得至少可以说明不讨厌。\n关于信息 该帖子推荐了许多有意思的CS相关Wikis：Awesome CS Wikis。\n关于计算机专业课 大二选择计科后，你会接触到很多计算机学院的专业课（包括必修与选修），充分感受到课程与考核的抽象——PPT 无法反映最新技术，是几十年一成不变的；考试无法反映真实理解水平，很多只是死记硬背；有些授课水平一言难尽，没有听的必要。\n至于该课程或者授课水平怎么样，可以在 BIT101 的课程界面上提前搜一搜，有一个印象。如果差评如潮，那么就要当心了。\n关于选修课 学校中选修课有两大类——全校公选课，以及专业选修课。前者全校都可以选修，要求的是 6-8 学分；后者是每个学院特有的，需要根据培养计划选够足够的学分，例如计科是 12 学分，计拔是 14 学分。这一届具体可以参考教务部的培养方案，目前 24 级还没有出。\n我大二上没有选修，大二下选修了两门。\n有学长建议从大二上到大四上（大四下没有专业选修课），每学期的选修课如下——1, 4, 1, 0, 1（针对 14 学分的情况）。然而我的可能是 0, 2, 2, 1, 2 或者 0, 2, 2, 0, 3。具体怎样，可以根据情况安排，不过有空还是提前多选一些比较好。\n个人来看，选修课可以分为三大类（具体这门课如何，可以参考 BIT101 上的评论与往年均分）——\n水，给分高。这类课通常很热门，能否抽到需要看运气。 硬核，给分低，但是能学到真东西。例如金旭亮老师的开发系列课程。 讲的烂，给分还低。这一类没有什么选择的必要。 关于给分 宏观来看，期末考试可能有三种形式——\n机考作答，例如 C 语言。这种形式较少，大二全年只有数字逻辑这门课是机考。 答题卡作答，例如大学物理、概率论。这些课程改卷相对公正，老师之间随机批改。 纸质试卷作答，最常见的形式。这类课程有较大的灵活性。 纸质试卷的灵活性就在于，大多数班级的纸质试卷，都是由授课老师亲自批改的。这就意味着有一定的放水空间。然而，不同老师的批改方式可能不完全统一，造成不同班级的考试结果不公平。所以，如果试卷答得很好，但期末成绩并不理想，或者是反过来，都可能有这方面的因素。\n关于考试时间 大二开始，许多专业课的考试都会塞满大量的题目，力求覆盖各类知识点。所以，考试的题量相当大，也很有可能做不完（例如离散数学、数值分析、数据库原理与设计等等）。\n并且，许多科目网上流传的往年卷都是“难度降低”版本的，实际考试的难度往往更高。建议提前做好思想准备，考场上根据作答情况，灵活调整时间，大胆跳过，避免出现最后时间不够的情况。\n关于专业路线 既然各位点进了这个攻略，应该或多或少选择了计算机相关专业。那么，作为相关专业的学生，应该了解专业要学习什么。\n在此推荐一下 HackWay 与 CSDIY 上的 CS 学习规划，各位可以参考名校的计算机培养方案，了解计算机的大致学习内容。\n接下来的介绍部分利用 Gemini 2.5 Pro 进行润色，AI 生成。本文其他部分都没有用到 LLM。\n接下来，我们用一个“盖房子”的比喻，自底向上地看看计算机科学的全景图：\n地基：物理与数学\n这是什么？ 一切的起点是物理学的半导体（晶体管）和数学的布尔代代数。它们告诉你如何用“开”和“关”这两个状态（0和1）来构建逻辑。 对应课程： 离散数学、数字逻辑电路。 一句话理解： 这是制造砖块（逻辑门）和水泥（运算规则）的方法。 框架结构：计算机体系结构\n这是什么？ 有了砖块，我们怎么把它们搭成一个能计算的“毛坯房”？CPU、内存、硬盘这些硬件如何协同工作？指令集（机器码）就是这个房子的“建筑指令”。为了方便人类理解，我们给机器码套上了一层“助记符”，这就是汇编语言。 对应课程： 计算机组成原理、汇编语言。 一句话理解： 设计房子的承重墙、房梁和水电线路，并规定了最基础的施工口令。 灵魂核心：算法与数据结构（贯穿所有层）\n这是什么？ 这是计算机科学的“内功心法”，是解决问题的通用“方法论”。无论你盖什么房子，都需要高效的组织材料（数据结构）和快速的施工方法（算法）。 对应课程： 数据结构、算法导论。 一句话理解： 它不是房子的一部分，而是盖房子的蓝图和施工工艺。学好它，你的“建筑水平”才能登堂入室。（这部分至关重要，请务必高度重视！） 内部装修与管理：系统软件\n这是什么？ 毛坯房太难住了，我们需要一个“物业管家”（操作系统）来管理水电（CPU、内存资源），安装“翻译器”（编译器）把我们人类说的高级语言（C++/Java/Python）翻译成机器能懂的“施工口令”。 对应课程： 操作系统、编译原理。 一句话理解： 从毛坯房到精装房，让房子变得宜居、易用。 对外连接：计算机网络\n这是什么？ 房子盖好了，但不能是孤岛。我们需要修路（网络协议），让我们的房子能和别的房子通信、交换信息。 对应课程： 计算机网络。 一句话理解： 为你的房子接上互联网，连接世界。 上层应用：入住与生活\n这是什么？ 房子终于可以入住了！你可以在里面做各种各样的事情，这就是我们日常接触到的软件和应用。这也是大家未来最可能从事的领域。 主要方向： Web开发： 建造各种网站（淘宝、B站），分为“装修”页面的前端和支撑服务的后端。 移动开发： 开发手机App（微信、抖音）。 人工智能/数据科学：训练聪明的“管家”（AI），让它帮你分析数据、识别图像。 游戏开发：在房子里建造一个虚拟游乐场。 对应课程： 数据库、软件工程、Web开发、机器学习等各类专业选修课。 一句话理解： 在精装房里享受生活，并创造出丰富多彩的应用。 了解这个全景图，你会发现，即使你未来只想做“室内设计”（前端开发），懂一点“建筑结构”（计组、OS）也能让你避免设计出奇葩的方案，遇到问题时能更快地定位到是“墙体”还是“装修”的问题。这就是我们常说的“建立知识体系”，它能决定你未来能走多远。\n关于自学 了解完上面的计算机学科架构后，便可以根据自己的情况，寻找相关资源进行自学。\n自学后，往往能更从容地应对课程内容，也能在学期内留出更多时间做别的事。例如，我大一结束后暑假学完了 CS61B，掌握了基础的数据结构与算法，所以面对大二上的数据结构课更加从容。\n另一方面，自学后也能看清课程的重点，同时知道课程的大体框架，知道每一部分的作用。这对于学习来说也是很重要的。\n关于缓考 有时，我们总会遇到突发情况——例如考前生病，无法参加考试。对于要保研的同学来说，可能会很担心这一点。\n实际上，有缓考的机制存在。只要在考试前提交缓考申请，就可以在下学期再次考试，不会影响你的成绩。\n由于我并没有缓考的经验，所以也向一些有缓考经验的同学请教过。特别感谢 Timothy 编写了详细的缓考攻略，请各位参考 Timothy 的博客。\n🔧 方法篇补充 我在之前的方法篇里面介绍了总体的想法——效率比时间重要，费脑子的学习行为才是有效的，要积极利用先进设备。这里我针对当下 LLM 发展、以及高效学习工作流进行补充，并提供关于考前突击的一些看法。\nLLM 发展 当今时代，LLM 发展迅猛。去年这个时候（24 年 6 月），最强的模型还是 GPT-4o，或者 Claude 3.5 Sonnet。到了 24 年 9 月，OpenAI o1 发布，是第一个具有推理能力（思维链）的模型。此后，25 年 1 月，Deepseek r1 发布，许多人第一次尝试了具有推理能力的模型。\n去年，如果你随便截一张作业的图扔给 GPT-4o，往往会得到错误的回答。现如今，截图扔给 Gemini 2.5 Pro，或者其他较强的最新模型（OpenAI o系列、Claude 4系列、Deepseek r1 0528、Doubao 1.6 等等）可以轻松得到高质量回复。这大大拓展了我们的学习能力。对着 PPT 哪里不理解，直接截图去问，或者把整个 PPT 喂过去。鉴于目前许多 LLM 拥有 100k 以上的长文本，同时有思维链与多模态能力，基本上 90% 甚至 99% 的知识点与题目，你都可以直接不懂就问。\n高效学习工作流 拥有一个高效的工作流是一个常见的话题，例如 CSDIY 上就有相应介绍。这里我主要针对应试，提供一种可能的方案。\n对于应试，较好的学习方案应该达到以下几点：\n可以充分利用现有资源，包括书籍、PPT、LLM 的回答等； 可以高效地复习知识点； 可以方便地刷往年题，并进行错题整理。 我下面提供的基于 MarginNote4（后面简称 MN4）的方案便满足了这几点。当然，有的同学更倾向于纸质材料学习，也有的同学没有苹果相关设备，不过下面只是一种可能的方案，供各位参考。各位的方案只要能达到上面那几点，就可以了。\n我从大一下开始尝试使用 MN4，整理了一点工科数学分析下的试卷。从大二上开始，除了思政课，我都不怎么买书，直接找电子版传入 MN4。\n对于 PPT 或课本中需要记忆的知识点，使用 MN4 的摘录工具形成卡片，每一个卡片正面就是对知识点的提示（例如正态分布的公式是什么），反面是具体知识点，例如： $$ f(x) = \\frac1{\\sigma\\sqrt{2\\pi}}\\; e^{-\\frac{\\left(x-\\mu\\right)^2}{2\\sigma^2} } $$根据每门课的篇章，可以划分为 4-10 个小部分，每一部分创建一个复习卡组。每个卡片绑定到相应复习卡组中，进入复习模式，便可以用记忆曲线的方式来复习卡片（类似 ANKI）。\n绑定后，你可以隔一两周甚至一两个月复习一次，期末周继续发力。鉴于 MN4 对 PDF 的支持很好，可以将各类资源统一转换为 PDF（PPT、课本、试卷等），并且统一进行刷题。例如你可以把往年 10 多届的试卷都导入，用平板刷题。遇到错题，可以轻易地使用摘录工具形成卡片，并绑定到复习卡组。此后连着知识点与错题一起复习。\n这种学习方法是比较高效的，至少我用这种方法可以高效地完成应试的工作。不过也有一些要求——因为 MN4 只支持 iOS 与 MacOS，你需要有 iPad 或者 Macbook，同时为了方便写，最好 iPad 买个笔（官方的太贵的，找一个平替即可）。\n有条件可以考虑 iPad+Macbook，通过苹果自带的多端复制，可以在 iPad 上复制题目图片，粘贴到 Mac 上问 LLM。或者使用屏幕镜像中的随航，将 iPad 作为 Mac 的副屏使用。\n当然，以上说的都是术，并非道。只要你能找到一个高效的工作流，不用过于在意具体的实现方式。上面只是一种可能的方案。\n考前突击补充 一些公共课有大量的往年题目（例如概率论、大学物理下），然而对于计算机学院的专业课，能找到一两套的久远的往年题都算不错了。\n这种试卷的缺失，在深度学习的角度，可以看成是分布迁移(distribution shift)，也即你的训练集与测试集的分布不同，导致泛化性能很弱。如果你做的都是书上面的题或者作业题，可能就与试卷上的题目相差很大。\n方法一 解决分布迁移有很多方法。最核心的还是多找一些真实数据，例如 best of bits 或者 BIT101 上的 CS 仓库整理 的资源推荐，上面每一个 repo 都看一看，自己整理得到更多试卷。一些其他的途径，例如 BIT101 网盘、贝塔驿站资料、睿信学指资料、学长学姐、身边其他老师班级的同学等，都尝试一下。\n方法二 ⚠️下面有一些公式，只是为了好看，不影响全文的阅读。⚠️\n解决分布迁移的第二个方法便是使用重要性采样。在概率论中，设随机变量 $x$ 服从某个概率分布，例如 $p(x)$。这里的 $x$ 可以代表考试题目，$p(x)$ 代表考试题目的概率密度（例如有些考试题目常见，有些题目少见）。假设得分函数 $f_\\theta(x)$ 是关于 $x$ 的函数，输入是题目，输出我们作答题目的得分，其中 $\\theta$ 代表可以通过学习改进的参数（例如我们大脑中的神经元）。我们学习的目标就是最大化考试得分，也就是 $f_\\theta(x)$ 的期望： $$ \\theta^* = \\mathop{\\arg\\max}\\limits_{\\theta}\\ \\mathbb{E}_{x\\sim p(x)}(f_\\theta(x)) $$但是，因为往年题较少，所以 $p(x)$ 难以采样。相反，其他来源的题目容易采样（例如书上课后题等），假设这些训练集的题目的概率分布满足另一个分布 $q(x)$。那么，我们可以根据期望的定义，展开原先的式子： $$ \\mathbb{E}_{x\\sim p(x)}(f_\\theta(x)) = \\int p(x)f_\\theta(x)dx $$ 接着，我们引入一个 “1”，进行化简：\n$$ \\mathbb{E}_{x\\sim p(x)}(f_\\theta(x)) = \\int p(x)f_\\theta(x)dx = \\int \\frac{q(x)}{q(x)}p(x)f_\\theta(x) dx = \\int \\frac{p(x)}{q(x)}f_\\theta(x)q(x) dx $$最后，可以根据期望的定义，将 $q(x)$ 与 $dx$ 结合，变成期望：\n$$ \\mathbb{E}_{x\\sim p(x)}(f_\\theta(x)) = \\int \\frac{p(x)}{q(x)}f_\\theta(x)q(x) dx = \\mathbb{E}_{x\\sim q(x)}(\\frac{p(x)}{q(x)}f_\\theta(x)) $$ 在此，我们证明了重要性采样，并且得到了重要性权重—— $\\frac{p(x)}{q(x)}$。直观来讲，现在你不需要从原先考试题的分布 $p (x)$ 当中采样，而只需要在平时练习题的 $q (x)$ 采样，并在学习时乘以重要性权重——也就是根据 $\\frac{p(x)}{q(x)}$ 进行判断，考试题的分布 $p (x)$ 越多，就越应该注重这个题目。\n（其实上面扯了这么多就是想写点公式） 大白话很简单——考试题考得多的地方就是重点，要多看；几乎没考过的地方就少看甚至不看。如果老师考前发了考纲，那自然不用管考纲上没出现的内容。\n方法三 解决分布迁移的第三个方法便是使用仿真数据或合成数据（做具身智能的喜欢叫仿真数据，做 LLM 的喜欢叫合成数据）。这方面我只是做了一点点尝试。\n在考数据科学与大数据的数学原理这门课前，我让 LLM 根据课件以及考纲，生成了一些题目。虽然不一定很好吧，但是也可以起到一定的练手作用。除了直接生成题目，你问 LLM 一道题后，让他做一些知识点的拓展与延伸，或者出一些类似题目，也可以算是使用仿真数据。\n小结 这三个方法，可以解决不少 分布迁移 的问题。从大模型的角度看，平时学习可以看成是海量的无监督学习（Unsupervised Learning），作业可以看成是有监督的微调（SFT），明确的模拟考试得分可以看成是 RL （这个类比可能不是那么恰当，就当是随便说说吧）。\n在无监督学习阶段，可以多补充一些材料，让自己更好理解（例如各类科普视频、科普书、博客、问 LLM 等等）。在有监督的微调阶段，如果试卷没有答案，可以写完后直接让 LLM 帮忙批改（一次不要问太多，3-5 小题或 1-2 个大题比较合适）。在 RL 阶段，完整地做一套试卷，重点是熟悉考试的题量，调整自己的时间安排。\n以上，对考前突击做了不少补充。也希望各位也可以多一些自信——即使平时没怎么学，甚至作业还是抄的或者让 ai 写的，也拥有考前一两周学完科目并且考高分的信心。事实上，如果你参加一些竞赛或科研活动，这几乎是唯一的选择。在日后，诸如研究生或职场，也不会有人给你 3-4 个月的时间完整学一个东西，最多用 1-2 周快速了解并熟悉。虽说对当下大学教育的诟病有许多，这种突击能力可能是未来真正会用到的技能吧。\n📃大二上课程攻略 互联网应用开发基础训练 如上面所述，今年起这门课与程序设计方法可能合并为了 3 分的一门课。\n小学期的课，1 学分。计拔、软工应该都有这门课。计科的好像叫 Web 开发基础，相比起来好像要求更死板。\n计拔与软工的这门课比较宽松，最后 3-4 人组队做一个产品。我们小组实现了一个交互式神经网络学习网站，可以拖拽式移动模块（例如 MLP 当中的神经元，CNN 当中的卷积层、池化层、全连接层等），并利用 Tensorflow.js 进行训练。最后高分。\n那还是在一年前 AI 不太行的时候，我就用了许多 AI 辅助。如今 AI 写前端相当牛，有什么想法都可以轻松实现了。均分 90.5。\n程序设计方法与实践 小学期的课，1 学分。就是刷 30 道算法题，没别的。\n想要认真学习算法建议参考下方《数据结构与算法设计》的资料推荐。这门课想要水让 AI 帮忙写就可以。均分 91.2。\n数据结构与算法设计 🗯️下一届开始，这门课拆成了 3.5 学分专门的数据结构，整体难度应该有所降低。🗯️\n5 学分的存在，注定了这是一门硬课。同时，这也是CS 四大件（数据结构和算法、计算机操作系统、计算机网络、计算机组成原理）之首，重要程度无需多言。\n如此重要的科目，自然有数不尽的优质资源。例如 CSDIY 上就有专门一节公开课推荐，其中有 CS61B、Coursera Algorithms、MIT 6.006、MIT 6.046、UCB CS170。我在大一暑假学完了 CS61B，收益颇丰，尤其是 SP21 的 Project2 Gitlet，需要你用 Java 手搓一个简化版 Git，整个项目大概 1000-2000 行。\n如果你是搞 acm 的，自然可以多看看 OI Wiki，刷一些洛谷 的题。\n在求职面试算法题方面，力扣当然少不了，也可以参考代码随想录刷一刷。Hello 算法也是一个入门资源。\n在考研 408 方面，可以刷一刷考研题。当时我刷了一些王道数据结构考研题（可以在 Anna\u0026rsquo;s Archive 上找电子版，也可参考 b站视频），记了很多比较偏的点。但是这个的分布迁移有些大，真正考试的选择题并没有那么难，知识点并不会考得那么全。\n虽然有如此多优质资源，BIT 的教学可谓是相当抽象，尤其是乐学上构思一般（甚至不如构思）的题目——从来不标注的数据范围与类型，从来不说明白的题意，从来没有的 starter code，注定了是一个折磨。一方面，这显然不贴近工程中写代码的环境，没能起到类似 CS61a、CS61b 中 project 的作用；另一方面，这也不贴近算法题，因为题干很多东西都不清楚，锻炼的不是你的算法能力，而是揣摩汉字，考虑数不清的 corner cases 的能力。\n课程上，我们这一届是数据结构+算法+设计理论。下一届开始这一门课又会分开。为什么我会说又呢？因为据说 4-5 年前这几门课就是分开的。设计理论考得很浅，就是一些定义与背诵，与前两者加在一起比较突兀。\n设计理论方面我还看了一半的 《GEB——哥德尔、埃舍尔、巴赫：集异璧之大成》。这本书我初中就因为科普视频接触过，不过看得一知半解，好像看了一半不到。这回重新看，还是感觉写得挺好，也相当有启发性。不过，我看了一半，之后又没看下去😂。\n考试上，选择+大题的形式。其中大题占大头（70 分左右），有 6-7 道算法设计题目。部分题目除了描述算法，还需要手写代码，比较恶心。\n因为上述提到的分布迁移问题，我没有花时间多做一些算法题，而是过于看重一些选择题的概念，最后喜提大二上考试最低分。不过这属实有点凡尔赛，因为相比均分也挺高的了（均分 76.7）。\n大学物理 A II 4 学分，相当硬的课，均分 75.0。包含电磁学与近代物理。考试带计算器。\n想要认真学，可以看郭爷（郭芃）在延河课堂上的课。理解方面，也许可以翻一翻 《费曼物理学讲义第二讲》。虽然我高中搞过物理竞赛，不过只会做力学题，电学方面了解不多。翻开费曼物理学讲义，又感受到了物理的一些兴趣 （不过这一届诺贝尔物理学奖颁给 AI，我也何尝不算是在学物理呢） 。工数下的一些工具（散度、旋度、各种线面积分等）还是挺有用的。\n刷题方面，课本每章后有习题，可以在辅导手册上找到详细解答。建议刷一刷。往年题也有很多，我好像是刷完了。我记得报名物理竞赛项目有加分，但是我因为较忙，没有参加。MOOC 上记得按时完成。\n离散数学 4 学分，这位更是重量级，均分 70.9。我在 BIT101 上已有过详细回答，可以参考。\n我们老师的成绩组成如下：\n平时作业，乐学提交，不硬性限时，15分。 上机，实际上没去机房，就是乐学上八道编程题，8分。我让 AI 写的。 研究性学习，在考试结束后两周内提交，相当于写一个小论文，7分。我的大作业在如何用大模型水一篇LaTeX论文？中有分享。 期末考试 70分。 几年前，离散的上下合并，从两学期合成为一学期，保留了数理逻辑、集合论、代数系统、图论四章。后两章难度显然更大，但前面也并不轻松。\n离散课本是经典的填鸭式教材，两页可以冒出十个甚至九个定义与定理，对概念的直观理解与具体示例较少。为此，我在考前一个月还读了一些书，例如曾经初中翻过一点的《数学女孩》系列，其中有几本与离散数学关系紧密，有对群论的直观讲解。各位感兴趣可以照过来看一看。\n群论还可以参考一些视频： 史上最好的群论入门-哔哩哔哩\n有能力建议看 Youtube，作者之后还上传了一个群论介绍视频： Simplifying problems with isomorphisms, explained — Group Theory Ep. 2\n这个系列也不错： 高中生就能看懂的群论，如何从对称性构建出群，群论01：什么是群-哔哩哔哩\n至于图论部分，我考前一周甚至两三天才开始突击的，较为折磨。概念一大堆，证明题也多。也可以b站搜点视频。\n如果你想要考好离散数学，还是需要下不少的功夫。你所找到的离散数学的“考试”卷，与真正的考试难度，拥有巨大的分布迁移，堪比学完1+1后考你微积分。\n23级，也就是24-25-1学期，离散数学试卷题型如下：\n10 道选择题，每题2分 10 道填空题，每题1分 8道大题，分为6分题与8分题，共60分。 这题量相当恐怖，我在快写完选择题时，发现时间流逝了不少，后面提速，最后也还有题没来得及写。考试时还是强烈建议遇到难题果断跳过。题目是按照章节顺序排列的，而不是难度顺序。虽说实际上最后一题图论证明题确实是最难的，但是第一题等值演算相当恶心，我直接放弃，最后回来根据分类讨论写了个结果。好在老师应该是尽可能给分的，我最后的成绩也相当不错。\n概率论与数理统计 经典数学课，3 学分，均分 78.7，考试难度还行。这同时也是考研数学的科目之一（除了高数与线代），所以b站上有一大把视频，资源相当多，想学好不难。\n理解方面，可以看《普林斯顿概率论读本》，其中伽马函数可以秒杀一些正态分布的积分题目。适当看一些更高级的内容，对简单题目确实有作用。\n应试方面，b站做一些考研题后，往年题十多套基本够用了。可能需要复习一些工数上与工数下的积分计算。考试不让带计算器。\n这门课有 MOOC，记得按时完成。\n马原 思政课，3 学分。考前可以看一些 b站视频，背一背概念。\n如果你本身就对马克思主义感兴趣，那么在理解的情况下，考试多写一写，得分应该挺不错的。这还是我大学以来思政课最高分😊。\n数值分析 😱 哎呀，骇死我了！ 😱\n这门课 2 学分，但是很恶心。均分 74.0，考试带计算器。BIT101 上课程评价中我写了考前的一个小插曲。\n好在这门课提前结课，有较为充足的复习时间。可以先看孙新老师的网课，大概理解每个公式是干什么的，然后带着理解背。\n在扩充资料方面，可以参考周华任的《数值分析习题精讲及考研辅导（清华第 5 版）》（Anna\u0026rsquo;s Archive 上可以找到），这上面许多题目可以参考。往年题比较充足，大概有 10 套左右。实际考试题量更大，需要抓紧时间写。身边许多同学考试没写完。\n比较搞人心态的是，你需要为同一个问题，记住多种算法，背多个公式。因为考试会指定一种特定的算法用来求解问题。\n建议熟悉一下计算器的使用，我之前写过《CASIO Is All You Need——数值分析计算器使用指南》，发到过 24 级学指群。也可以看这个夸克网盘链接。\n物理实验下 1 学分，没有绪论，总共 11 个实验。\n这个就不用多说了，想办法找已有的实验报告，然后改数据对着抄。不要为这种区分度很低的 1 学分的课浪费精力👿。（均分 88.6）\n📑大二下课程攻略 大二下还是比大二上轻松不少，想要保外并且不是走拿牌子路线的同学，建议想办法进组实习。可以根据自己感兴趣的方向，套磁外校（北京更牛的就是清北中科院吧）或本校的老师。\n⚠️注意⚠️：因为现在有些课还没出分，所以未来我可能会进行更新，补充均分等。\n数据库原理与设计 3 学分，这学期学分最多的专业课，均分 79.3。知识点很多很杂。\n其中，前四章还算连贯。但是第五章开始，基本上每一章就是一个独立的话题，互不干扰——优化、安全性、完整性、恢复、并发处理、设计理论等。每一章都有许多要记忆的知识点。\n一些知识点可以参考北京理工大学数据库复习总结。不过这个我看得不多，可以做补充作用。我看的主要还是 PPT。\n往年题就只有几套，很少。建议使用上方提到的解决分布迁移的一些方法。\n多利用 LLM 的力量，每一章的 PPT 都可以输出 PDF 扔进去，然后问一些问题，帮助理解。\n期末占比 70%，题型如下：\n20 分填空题，一空一分； 10 分判断题，一题一分； 16 分单选题，一题一分； 10+ 分简答题，有四小问，每一问简要解释一个概念； 20+ 分作答题，5 大题，每一题还有小问，设计了许多章节的知识点； 20 分设计题，根据需求，画 E-R 图，转换为关系模型，最后利用 SQL 创建视图与触发器。 题量是相当大的，我身边很多同学没写完。我考场上意识到不简单，抓紧时间，最后勉强写完。\n面向对象技术与方法 2.5 学分，笔试，均分 84.6。经典的陈旧 PPT ，很多就是偏难怪知识点的记忆，并没有起到学习面向对象思想的作用（真正的知识还是建议按国外公开课学习）。\n考试题是选择题、程序填空与输出判断、手写代码。\n有同学推荐 learncpp ，不过我没看过。C++ 好像 Stanford CS106 也会涉及，不过我也没看过😢。\n往年题更是稀少，我看到的只有两三套。不过 PPT 当中已经覆盖了很多偏难怪的点了。\n数据科学与大数据技术的数学基础 2 学分，少见的好课程。大数据以及计拔会学这门课。（余老师这学期喉咙有些不太好，所以讲课上比较小声） 不过 PPT 是相当优质的。在当今 AI 发达的时代，很多可以直接问 AI。\n30 分平时分是乐学的选择题，5 次，每次 6 道题。70 分是考试分。\n随机算法方面，我觉得多问问 AI 就可以解决。谱分解方面，强烈推荐鸢尾花书 矩阵力量，里面用相当形象的方式，多视角详细讲解了特征值分解、主成分分析、奇异值分解等等。相信你看完能建立很强的几何直观，回过头来看 PPT 就比较轻松了。如果你入门机器学习，其实整个鸢尾花书系列我都很推荐（虽说我最后的几本书还没怎么看）。\n最后一章压缩感知也有点意思。不过我没怎么找补充材料，应试来看 PPT 当中的内容肯定是够用了的。\n虽说均分 80.7 看着不高，但老师在群里面说计拔有8位同学卷面满分（共19人），可能是方差比较大吧🤔。\n毛中特 3 学分，思政课。\n思政课其实套路都差不多，多回答问题，小组展示的时候多讨论一下，积极合作。最后突击看一些视频，考场上用连贯的语言来写（不要仅仅是分点作答，这样老师不喜欢）。\n数字逻辑 2.5 学分，均分 85.4。最后是机考，41 道选择题（我也不知道为什么不是更整的 40 道题）。比较逆天的是，机考无法回头，做一道题过一道。如果后面有题启发了你，你会意识到前面有题目做错，但自己无法修改，这种感觉很痛苦 （太↑痛↑苦↓了→，太↑痛↑苦↓了！😭）。\n强烈推荐 Steam 上的游戏图灵完备。就算买的时候不打折，我认为 70rmb 是相当值的。为了应对数字逻辑这门课，玩到图灵完备成就肯定就足够了。后面还有汇编部分，我也还没玩。（看一眼小黑盒，上次打折是今年 6 月 1 日到 15 日，通常一年多才打折一次。不过不打折就多花 20r，推荐直接入手）\n比较恶心的是，作业题布置的是 2-4 章，没有第五章作业，给你一种第五章不重要的错觉。实际上，期末考试第五章题还不少，可能占到 1/5 左右。这部分一定要多看。CMOS相关可以参考Branch Education的这期视频。\n可以参考北京理工大学数字逻辑期末考试复习，这个网站整理得相当好，也有许多题目，方便边看边做。（避免出现 “全是字，一道例题也没有” 的情况）\n往年题就只有一两套，好像是疫情期间机考有人截图流传下来的。我个人感觉这一届实际难度是变高了不少的，有些题目是“升级版”。\n课程还需要小组实验拿板子，跑代码。我是一个人直接用 LLM 完成的（在 Cursor 当中）。源代码很方便用 Cursor 编辑，具体编译以及上板都是用 Vivado 实现的。（还是先要在 Vivado 中创建文件，然后才在 Cursor 中编辑，不然无法识别）\n深度学习基础 选修课，2 学分，均分 89.8。前几年均分好像才 80 多，这一届均分变高了不少。\n真知识都靠自学，不要指望通过这门课来入门深度学习。\n如果你已经了解深度学习方向，并且有卡，那么推荐这门课。可以在讲台上讲一讲自己的研究方向，这样有10-20分加分。\n最后的大作业需要实现目标检测。在如今LLM时代，这应该不是很难。\n算法博弈论 选修课，2 学分，均分 89.7。\n前几年是每个人单独提交报告，所以最高分也只有 96-97 左右。今年 3-4 人小组提交各类作业，最后得分根据小组内部商量决定。\n具体来说，你可以填写一个表格——当总得分100时，小组各成员得分的平均数应该是100；总得分90时，小组各成员得分的平均数是90 。\n不过实际上，我觉得大部分组可能还是平均填写。所有作业、ppt、报告等，最后都只需要组长提交。\n在当今的LLM时代，我们组并没有花很大精力看真正的内容，而是直接让LLM做所有的工作。为了方便理解，我还用Claude Code Vibe Coding为final report做了一个可视化网站，解释其中的核心概念。最后得分很不错。\n🎉尾声 到现在差不多纯字数有 10000 多，算上字符有 16000 了。\n也希望上述整理可以或多或少帮到一些人吧。相信大部分看到这里的同学，要么是即将大二，要么是即将大三。如果有机会，你也许也可以向学弟学妹分享一些心得🤩。毕竟我可能只是站在很优秀的角度去看，看起来没有踩那么多的坑。\n未来有时间也许也会整理一些科研入门教程等，不过估计这个暑假挺忙的）随缘吧。\n最后，真诚感谢 Frozen heart、JyYeah、ListenSnow、Lucien、NoMad、Omnipotent、Quan、Reina、Spranty、酸菜不吃鱼、Timothy 等同学的帮助！（首字母排序，不分先后）\n正是有了你们对本文的大力支持，并提出了许多有意义的建议，我才能不断完善内容。正文也从一开始 6000 多字，扩充到了 10000 字。\n同时，也感谢所有曾经在专业选择上或其他地方帮助过我的学长学姐，让我逐渐看清方向，并不断前行！\n","date":"2025-07-08T00:00:00Z","image":"https://ovideros.site/p/guidance2/guidance2_hu_214f0d18d2b73ad3.jpg","permalink":"https://ovideros.site/p/guidance2/","title":"计科大二通关指南"},{"content":" ⚠️ 注意，本文只提供个人的解法与思路，不能代替自己亲手用调试器做实验。如果你希望更好地锻炼自己的能力，仅仅在你尝试过，并且被卡住时候，观看对应章节的内容。或者，在你独立做完实验，可以与本指南中的内容核对。也欢迎各位对本文中的拼写错误、细节遗漏等方面进行补充！\n本文受到了 更适合北大宝宝体质的 Bomb Lab 踩坑记 很大的启发，因此你可能发现一些雷同的内容，这都只是我的拙劣模仿。\n实验介绍 本实验是 CSAPP 第三章的实验内容，设计了汇编的许多方面，包括整数运算、字符串比较、循环条件分支、递归调用、栈、指针、链表、结构等等。本文读者应当学习过以上内容，进而更好地理解该实验。\nBomblab 的实验背景相当经典，可以在 bomb.c 中看到。简单来说，你需要根据二进制程序来拆弹💣。\n实验准备 实验暴露出来的源码 bomb.c 只涵盖了一小部分，没有涉及每个函数具体是如何实现的。不过，我们可以从中看出大概流程——获取输入，然后执行下面的函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 initialize_bomb(); printf(\u0026#34;Welcome to my fiendish little bomb. You have 6 phases with\\n\u0026#34;); printf(\u0026#34;which to blow yourself up. Have a nice day!\\n\u0026#34;); /* Hmm... Six phases must be more secure than one phase! */ input = read_line(); /* Get input */ phase_1(input); /* Run the phase */ phase_defused(); /* Drat! They figured it out! * Let me know how they did it. */ printf(\u0026#34;Phase 1 defused. How about the next one?\\n\u0026#34;); // 更多内容 每次都读取一行作为输入，给 phase_n ，然后运行 phase_defused 函数。\n为了调试二进制程序，需要使用 gdb。我已经在之前的文章中，介绍了 GDB Dashboard 以及 pwndbg。为了更好的体验，建议先配置 pwndbg ，但这不是必需的。本文前四个阶段使用 GDB Dashboard，后两个阶段使用 pwndbg。\n参考北大Bomblab踩坑记1，该实验用到的常用调试指令如下：\n指令 全称 描述 r run 开始执行程序，直到下一个断点或程序结束 q quit 退出 GDB 调试器 ni nexti 执行下一条汇编指令，但不进入函数内部 si stepi 执行当前汇编指令，如果是函数调用则进入函数 b break 在指定位置设置断点 c cont 从当前位置继续执行程序，直到下一个断点或程序结束 p print 打印变量的值 x 打印内存中的值 注意 n 或者 q 指令是直接进行一步源代码指令，因此该实验中不会用到。p 是打印变量的值，通常是寄存器，不过在 pwndbg 的存在下没什么必要。x 是打印某个地址对应的值，也可以看做进行一次解引用操作，相当常用。\n一些常用指令：\n1 2 3 4 5 6 7 8 9 x/2x $rsp # 以十六进制格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/2d $rsp # 以十进制格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/2c $rsp # 以字符格式查看栈指针 %rsp 指向的内存位置 M[%rsp] 开始的两个单位。 x/s $rsp # 把栈指针指向的内存位置 M[%rsp] 当作 C 风格字符串来查看。 x/b $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 1 字节。 x/h $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 2 字节（半字）。 x/w $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 4 字节（字）。 x/g $rsp # 检查栈指针指向的内存位置 M[%rsp] 开始的 8 字节（双字）。 注意 / 后面的后缀（如 2x、2d、s、g、20c）指定了查看内存的方式和数量。具体来说：\n第一个数字（如 2、20）指定要查看的单位数量。 第二个字母（如 x、d、s、c）指定单位类型和显示格式，其中： c / d / x 分别代表以字符 / 十进制 / 十六进制格式显示内存内容。 s 代表以字符串格式显示内存内容。 第三个字母（如 b / h / w / g）分别代表以 1 / 2 / 4 / 8 字节为单位（unit）显示内存内容。 为了方便每次运行 gdb bomb 都能进入我们想要的部分，可以编辑当前文件夹下的 .gdbinit 文件（注意还需要更改系统的~/.config/gdb/gdbinit，参考GDB Dashboard 教程 ）：\n1 2 3 4 5 6 7 8 9 10 11 12 set args psol.txt b phase_1 #b phase_2 #b phase_3 #b phase_4 #b phase_5 #b phase_6 #b phase_defused setupwin /dev/pts/5 这当中 set args 可以指定参数。当前目录下的 psol.txt 文件的每一行，就是对每一个阶段的解答。这样每次完成一个阶段，都可以写入 psol.txt 文件，不用重复输入密码。\n断点可以根据当前阶段设置。# 开头的是注释。例如当前完成了前两个阶段，就可以只为第三阶段开启。\n最后一行是我为 pwndbg 自定义的函数，为了打印调试信息到指定内容，参考 pwndbg 教程与自定义配置。\n同时，因为 GDB 或者 pwndbg 能看到的反汇编代码的范围有限，为了方便查找，可以一次性生成反汇编代码并存储：\n1 objdump -d bomb \u0026gt; bomb.asm 这样就可以在 VSCode 中查找。\n如果你发现 CSAPP Labs 只有远程桌面，其实你可以简单地把 gitlab 链接复制，在本地或其他指定的地方克隆下来，运行即可。例如我使用的是一个远程 Ubuntu 电脑，本地使用 VSCode SSH，以及直接利用 Tabby SSH 连接。\n本文中不区分 eax 与 rax 等 32 位与 64 位寄存器，认为是等价的。本文中十六进制尽量使用 0x 前缀开头，但可能有遗漏。\nphase_1 运行程序 gdb bomb，然后输入 run：\n1 2 3 4 (gdb) run Starting program: /home/ywr/dsc/learn/csapp/bomblab/bomb psol.txt Welcome to my fiendish little bomb. You have 6 phases with which to blow yourself up. Have a nice day! 此时可以随意输入一些尝试，例如我输入 123456 并回车，就进入了 phase_1 的断点：\n1 2 Breakpoint 1, 0x0000000000400e6d in phase_1 () (gdb) 搜索 phase_1，可以看到如下代码：\n1 2 3 4 5 6 7 8 9 10 0000000000400e6d \u0026lt;phase_1\u0026gt;: 400e6d:\t48 83 ec 08 sub $0x8,%rsp 400e71:\tbe d0 23 40 00 mov $0x4023d0,%esi 400e76:\te8 cf 04 00 00 callq 40134a \u0026lt;strings_not_equal\u0026gt; 400e7b:\t85 c0 test %eax,%eax 400e7d:\t75 05 jne 400e84 \u0026lt;phase_1+0x17\u0026gt; 400e7f:\t48 83 c4 08 add $0x8,%rsp 400e83:\tc3 retq 400e84:\te8 be 05 00 00 callq 401447 \u0026lt;explode_bomb\u0026gt; 400e89:\teb f4 jmp 400e7f \u0026lt;phase_1+0x12\u0026gt; 可以看到，第三步调用了 strings_not_equal 函数。让我们输入两次 ni，到达 0x400e76 处。\n1 2 3 4 (gdb) ni 0x0000000000400e71 in phase_1 () (gdb) ni 0x0000000000400e76 in phase_1 () 汇编中第一个与第二个参数分别是 %rdi 与%rsi，让我们尝试打印：\n1 2 3 4 (gdb) p/x $rdi $1 = 0x603780 (gdb) p/x $rsi $2 = 0x4023d0 我们将这两个看成字符串指针，尝试打印：\n1 2 3 4 (gdb) x/s $rdi 0x603780 \u0026lt;input_strings\u0026gt;: \u0026#34;123456\u0026#34; (gdb) x/s $rsi 0x4023d0: \u0026#34;Slave, thou hast slain me. Villain, take my purse.\u0026#34; 可以看出，其中 123456 就是我们输入的字符，也是 input_strings。剩下的就应该是第一阶段的密码了。\n阅读原先汇编的逻辑，也可以知道在 strings_not_equal 调用后，会利用 test %eax,%eax 来判断返回值是否为 0（test 指令会对两个操作数进行按位与运算），之后根据 jne 进行跳转。如果不为 0，则跳转到 0x400e84，然后调用 explode_bomb 函数，引发爆炸；如果为 0，说明字符串匹配，则恢复栈指针位置，然后返回。\n所以第一阶段密码为 Slave, thou hast slain me. Villain, take my purse. 。\nphase_2 read_six_numbers 分析 调用 read_six_numbers 后爆炸，对该函数打断点。\nrcx 写为 0x00007fffffffdb44，rax 写为 0x00007fffffffdb54，推入栈，然后写为 0x00007fffffffdb50，再推入栈。r9 为0x00007fffffffdb4c，r8 为0x00007fffffffdb48 。\n调用前，rdi 为 0x00007fffffffd4d0，rsi 为 0x00000000004025c3。\n打印 sscanf 输入参数对应位置：\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; x/s $rdi 0x6037d0 \u0026lt;input_strings+80\u0026gt;: \u0026#34;123456\u0026#34; \u0026gt;\u0026gt;\u0026gt; x/s $rsi 0x4025c3: \u0026#34;%d %d %d %d %d %d\u0026#34; 发现其中第一个参数就是我们输入的字符串，第二个就是指定的格式。参考 sscanf 的使用方法2：\n1 int sscanf ( const char * s, const char * format, ...); 函数返回值代表捕捉到的参数个数。第一个参数是输入字符串（如 123456），第二个是指定格式（如 %d %d %d %d %d %d），之后的参数都是指针，指向希望存储数据的位置。\n根据定义，第三个参数开始分别是 rdx、rcx、r8、r9，超过六个参数都会压入调用者的栈中。注意，栈顶是从内存大区域往小区域的，并且压入的参数是逆序的，也就是先压入第8个参数，再压入第7个参数。所以地址最大的 %rsi+0x14 是最先压入的，也就是最后的参数。\n调用后，返回值 eax 会与 5 比较，如果小于等于 5，则会直接爆炸。这说明我们应该符合格式，输入 6 个整数进行尝试，如 1 2 3 4 5 6。在 0x401486 处停下，打印这些变量，就可以得到此时这些变量。打印的是现在 rsi 指向的地址，也就是0x7fffffffdb40。\n1 2 3 \u0026gt;\u0026gt;\u0026gt; x/6dw 0x7fffffffdb40 0x7fffffffdb40: 0 0 4199486 0 0x7fffffffdb50: -9112 32767 目前都为空。经过 sscanf 函数后再次打印：\n1 2 3 \u0026gt;\u0026gt;\u0026gt; x/6dw 0x7fffffffdb40 0x7fffffffdb40: 1 2 3 4 0x7fffffffdb50: 5 6 我们发现这就是 sscanf 获得的输入，将我们的输入存到了 6 个 int 类型中，放在栈上，是连续的六个变量。\n参数 值/指向的地址 指向的值 rdx %rsi 1 rcx %rsi+0x4 2 r8 %rsi+0x8 3 r9 %rsi+0xc 4 第七个参数 %rsi+0x10 5 第八个参数 %rsi+0x14 6 phase_2 本身分析 之后来分析 phase_2 本身。该部分有详细的汇编注释，但之后的汇编中我会减少相关注释。注意下面的 emoji 代表了跳转的位置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 0000000000400e8b \u0026lt;phase_2\u0026gt;: # ...省略... 400ea3:\te8 c1 05 00 00 callq 401469 \u0026lt;read_six_numbers\u0026gt; # 获取六个数字 400ea8:\t83 3c 24 00 cmpl $0x0,(%rsp) # rsp 第一个数字 与 0 比较 400eac:\t78 07 js 400eb5 \u0026lt;phase_2+0x2a\u0026gt; # 有符号比较，当第一个数字为负数的时候跳转到爆炸 400eae:\tbb 01 00 00 00 mov $0x1,%ebx # 将 ebx 变为1 400eb3:\teb 11 jmp 400ec6 \u0026lt;phase_2+0x3b\u0026gt; # 无条件跳转到 ec6 一行😭 400eb5:\te8 8d 05 00 00 callq 401447 \u0026lt;explode_bomb\u0026gt; # 爆炸 400eba:\teb f2 jmp 400eae \u0026lt;phase_2+0x23\u0026gt; 400ebc:\t48 83 c3 01 add $0x1,%rbx # 😁：rbx += 1 400ec0:\t48 83 fb 06 cmp $0x6,%rbx # 将 rbx 与 6 比较 400ec4:\t74 12 je 400ed8 \u0026lt;phase_2+0x4d\u0026gt; # 如果相等，说明循环结束，跳转到🚩 400ec6:\t89 d8 mov %ebx,%eax # 😭：eax 变成 ebx 400ec8:\t03 44 9c fc add -0x4(%rsp,%rbx,4),%eax # eax += rsp对应数组中rbx偏移量后减去4，也就是rbx为1 2 3分别对应数组索引 0 1 2，也即 rsp[rbx-1] 400ecc:\t39 04 9c cmp %eax,(%rsp,%rbx,4) # 将 rsp[rbx] 与 eax 比较 400ecf:\t74 eb je 400ebc \u0026lt;phase_2+0x31\u0026gt; # 如果相等，跳转到😁 400ed1:\te8 71 05 00 00 callq 401447 \u0026lt;explode_bomb\u0026gt; 400ed6:\teb e4 jmp 400ebc \u0026lt;phase_2+0x31\u0026gt; 400ed8:\t48 8b 44 24 18 mov 0x18(%rsp),%rax # 🚩：此时循环结束，将 rax 变成 rsp 地址加上 18 400edd:\t64 48 33 04 25 28 00 xor %fs:0x28,%rax # 异或比较 400ee4:\t00 00 400ee6:\t75 06 jne 400eee \u0026lt;phase_2+0x63\u0026gt; # 如果不相等，跳转到最后一行 400ee8:\t48 83 c4 20 add $0x20,%rsp # rsp 增加 20 400eec:\t5b pop %rbx # 推出元素 400eed:\tc3 retq @ 返回 400eee:\te8 0d fc ff ff callq 400b00 \u0026lt;__stack_chk_fail@plt\u0026gt; # 报错 可以跟着编译器，看出其跳转的逻辑，写成 C 的话类似这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int[] rsp; int eax; if (rsp[0] \u0026lt; 0 ) { explode(); } int ebx = 1; do { eax = ebx; eax += rsp[ebx-1]; if (!(eax = rsp[ebx])) { explode(); } ebx++; } while (ebx != 6) 所以，第一个循环 eax 为 1，并且 eax 加上数组第 0 个元素，判断是否等于数组第 1 个元素；之后继续循环。\n可以有多种解，就是一个二阶等差数列（二次函数），相邻两个元素的差是 1 2 3 4 5。同时保证第一个数不小于 0 即可：\n1 2 3 4 0 1 3 6 10 15 1 2 4 7 11 16 2 3 5 8 12 17 ... phase_3 在 sscanf 调用前，esi 便是第二个输入参数，代表了匹配的格式，打印得出：\n1 2 \u0026gt;\u0026gt;\u0026gt; x/s $rsi 0x4025cf: \u0026#34;%d %d\u0026#34; 这说明第三阶段希望匹配两个整数。前面将函数第三个参数 rdx 设置为 rsp 地址，第四个参数 rcx 设置为 0x4(%rsp) ，说明 rsp 指向了我们输入的两个数。\n1 2 3 4 5 6 7 8 9 10 0000000000400ef3 \u0026lt;phase_3\u0026gt;: 400f0f:\tbe cf 25 40 00 mov $0x4025cf,%esi 400f14:\te8 87 fc ff ff callq 400ba0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 400f19:\t83 f8 01 cmp $0x1,%eax # 比较 sscanf 返回值与 1 400f1c:\t7e 10 jle 400f2e \u0026lt;phase_3+0x3b\u0026gt; # 如果小于等于1，则爆炸 400f1e:\t83 3c 24 07 cmpl $0x7,(%rsp) # 比较 rsp 指向的值与 7 400f22:\t77 42 ja 400f66 \u0026lt;phase_3+0x73\u0026gt; # 如果大于7，爆炸 400f24:\t8b 04 24 mov (%rsp),%eax # 否则将 rsp 指向的值放入 eax 400f27:\tff 24 c5 40 24 40 00 jmpq *0x402440(,%rax,8) # 将 rax 作为索引，跳转到指定位置 ... 尝试输入 1 2。调试发现 0x400f1e 步 rsp 指向的值为 1，也就是我们输入的第一个数。接下来与 7 进行比较，然后有一大堆跳转。不难想到，这是 switch 的跳转表。可知表的位置在 0x402440 ，尝试打印（打印 8 个单位，以十六进制，每个单位有 8 个字节）。\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; x/8xg 0x402440 0x402440: 0x0000000000400f72 0x0000000000400f35 0x402450: 0x0000000000400f3c 0x0000000000400f43 0x402460: 0x0000000000400f4a 0x0000000000400f51 0x402470: 0x0000000000400f58 0x0000000000400f5f 这就是输入数从 0 到 7 的时候，对应的跳转位置。让我们根据下面的代码进行分析，加上注释，将第一个输入称为 x：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 400f1e:\t83 3c 24 07 cmpl $0x7,(%rsp) 400f22:\t77 42 ja 400f66 \u0026lt;phase_3+0x73\u0026gt; 400f24:\t8b 04 24 mov (%rsp),%eax 400f27:\tff 24 c5 40 24 40 00 jmpq *0x402440(,%rax,8) 400f2e:\te8 14 05 00 00 callq 401447 \u0026lt;explode_bomb\u0026gt; 400f33:\teb e9 jmp 400f1e \u0026lt;phase_3+0x2b\u0026gt; # 调到rsp的值与7的比较 400f35:\tb8 35 02 00 00 mov $0x235,%eax # x = 1 400f3a:\teb 3b jmp 400f77 \u0026lt;phase_3+0x84\u0026gt; 400f3c:\tb8 a7 01 00 00 mov $0x1a7,%eax # x = 2 400f41:\teb 34 jmp 400f77 \u0026lt;phase_3+0x84\u0026gt; 400f43:\tb8 2b 02 00 00 mov $0x22b,%eax # x = 3 400f48:\teb 2d jmp 400f77 \u0026lt;phase_3+0x84\u0026gt; 400f4a:\tb8 6c 00 00 00 mov $0x6c,%eax # x = 4 400f4f:\teb 26 jmp 400f77 \u0026lt;phase_3+0x84\u0026gt; 400f51:\tb8 f1 02 00 00 mov $0x2f1,%eax # x = 5 400f56:\teb 1f jmp 400f77 \u0026lt;phase_3+0x84\u0026gt; 400f58:\tb8 3e 00 00 00 mov $0x3e,%eax # x = 6 400f5d:\teb 18 jmp 400f77 \u0026lt;phase_3+0x84\u0026gt; 400f5f:\tb8 48 02 00 00 mov $0x248,%eax # x = 7 400f64:\teb 11 jmp 400f77 \u0026lt;phase_3+0x84\u0026gt; 400f66:\te8 dc 04 00 00 callq 401447 \u0026lt;explode_bomb\u0026gt; 400f6b:\tb8 00 00 00 00 mov $0x0,%eax 400f70:\teb 05 jmp 400f77 \u0026lt;phase_3+0x84\u0026gt; 400f72:\tb8 21 01 00 00 mov $0x121,%eax # x = 0 400f77:\t39 44 24 04 cmp %eax,0x4(%rsp) # 继续运行，比较eax 与第二个输入数字的值 400f7b:\t74 05 je 400f82 \u0026lt;phase_3+0x8f\u0026gt; # 如果相等，跳转到下方 400f7d:\te8 c5 04 00 00 callq 401447 \u0026lt;explode_bomb\u0026gt; # 不然爆炸 400f82:\t48 8b 44 24 08 mov 0x8(%rsp),%rax # 开始各种栈相关的操作 400f87:\t64 48 33 04 25 28 00 xor %fs:0x28,%rax 400f8e:\t00 00 400f90:\t75 05 jne 400f97 \u0026lt;phase_3+0xa4\u0026gt; 400f92:\t48 83 c4 18 add $0x18,%rsp 400f96:\tc3 retq 400f97:\te8 64 fb ff ff callq 400b00 \u0026lt;__stack_chk_fail@plt\u0026gt; 通过注释，我们不难发现，当 x 从 0 遍历到 7 的时候，都会通过一行 mov 命令设置 eax 的值，然后跳转到 0x400f77，将 eax 与第二个输入进行比较。如果不相等，就爆炸。\n因此可以得出多种解法，只要让第二个参数，与对应的 mov 中的硬编码的值一样即可。注意之前 sscanf 的 %d 只能匹配十进制输入，所以需要将十六进制进行转换。\n原先十六进制：\n1 2 3 4 5 6 7 8 0 0x121 1 0x235 2 0x1a7 3 0x22b 4 0x6c 5 0x2f1 6 0x3e 7 0x248 转换为十进制：\n1 2 3 4 5 6 7 8 0 289 1 565 2 423 3 555 4 108 5 753 6 62 7 584 任意一行都是有效的解。\nphase_4 phase_4 本身分析 照样有 sscanf 函数，打印出 rsi，发现还是两个整数：\n1 2 \u0026gt;\u0026gt;\u0026gt; x/s $rsi 0x4025cf: \u0026#34;%d %d\u0026#34; 第三个参数 rdx 设置为 rsp 地址，第四个参数 rcx 设置为 0x4 (%rsp) ，与第三阶段一样，还是将两个输入存放在 rsp 指向的位置。\n调用 sscanf 后先检验返回值是否为 2，如果不是，直接爆炸。接着比较 rsp 指向的值，也就是第一个输入与 0xe（14） 的关系，如果小于等于 14，正常跳转；否则爆炸。\n1 2 3 4 5 6 7 400ff7:\tbe cf 25 40 00 mov $0x4025cf,%esi 400ffc:\te8 9f fb ff ff callq 400ba0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 401001:\t83 f8 02 cmp $0x2,%eax # 检验返回值是否为2 401004:\t75 06 jne 40100c \u0026lt;phase_4+0x31\u0026gt; 401006:\t83 3c 24 0e cmpl $0xe,(%rsp) 40100a:\t76 05 jbe 401011 \u0026lt;phase_4+0x36\u0026gt; # 如果rsp指向的值小于等于14，跳转 40100c:\te8 36 04 00 00 callq 401447 \u0026lt;explode_bomb\u0026gt; # 爆炸 分析接下来的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 401011:\tba 0e 00 00 00 mov $0xe,%edx 401016:\tbe 00 00 00 00 mov $0x0,%esi 40101b:\t8b 3c 24 mov (%rsp),%edi 40101e:\te8 79 ff ff ff callq 400f9c \u0026lt;func4\u0026gt; 401023:\t83 f8 03 cmp $0x3,%eax 401026:\t75 07 jne 40102f \u0026lt;phase_4+0x54\u0026gt; 401028:\t83 7c 24 04 03 cmpl $0x3,0x4(%rsp) # 将第二个数字与 3 比较 40102d:\t74 05 je 401034 \u0026lt;phase_4+0x59\u0026gt; 40102f:\te8 13 04 00 00 callq 401447 \u0026lt;explode_bomb\u0026gt; 401034:\t48 8b 44 24 08 mov 0x8(%rsp),%rax # 正常操作 401039:\t64 48 33 04 25 28 00 xor %fs:0x28,%rax 401040:\t00 00 401042:\t75 05 jne 401049 \u0026lt;phase_4+0x6e\u0026gt; 401044:\t48 83 c4 18 add $0x18,%rsp 401048:\tc3 retq 401049:\te8 b2 fa ff ff callq 400b00 \u0026lt;__stack_chk_fail@plt\u0026gt; 设置 edx 为 14，esi 为 0，edi 为第一个数字的值，然后调用 func4 函数。\n根据输入参数顺序，可以 func4 第一个参数 rdi 为第一个数字，第二个参数为 rsi 为 0，第三个参数 rdx 为 14 。\n调用后将返回值与 3 比较，如果不一样，直接爆炸；否则将第二个输入与 3 比较，如果不相等，直接爆炸。所以这里可以确定第二个输入为 3 。\n所以，剩下来就看 func4 是如何处理 eax 的，让 fun4 返回值为 3。\nfunc4 分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 0000000000400f9c \u0026lt;func4\u0026gt;: 400f9c:\t48 83 ec 08 sub $0x8,%rsp 400fa0:\t89 d0 mov %edx,%eax 400fa2:\t29 f0 sub %esi,%eax 400fa4:\t89 c1 mov %eax,%ecx 400fa6:\tc1 e9 1f shr $0x1f,%ecx 400fa9:\t01 c1 add %eax,%ecx 400fab:\td1 f9 sar %ecx 400fad:\t01 f1 add %esi,%ecx 400faf:\t39 f9 cmp %edi,%ecx 400fb1:\t7f 0e jg 400fc1 \u0026lt;func4+0x25\u0026gt; 400fb3:\tb8 00 00 00 00 mov $0x0,%eax 400fb8:\t39 f9 cmp %edi,%ecx 400fba:\t7c 11 jl 400fcd \u0026lt;func4+0x31\u0026gt; 400fbc:\t48 83 c4 08 add $0x8,%rsp 400fc0:\tc3 retq 400fc1:\t8d 51 ff lea -0x1(%rcx),%edx 400fc4:\te8 d3 ff ff ff callq 400f9c \u0026lt;func4\u0026gt; 400fc9:\t01 c0 add %eax,%eax 400fcb:\teb ef jmp 400fbc \u0026lt;func4+0x20\u0026gt; 400fcd:\t8d 71 01 lea 0x1(%rcx),%esi 400fd0:\te8 c7 ff ff ff callq 400f9c \u0026lt;func4\u0026gt; 400fd5:\t8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 400fd9:\teb e1 jmp 400fbc \u0026lt;func4+0x20\u0026gt; 首先将栈指针 rsp 减小，edx（14）放入 eax，减去 esi（0），再放到 ecx，向右移位 0x1f，也就是 31 位，ecx 变成 0 。ecx 加上 eax 变成 14。单独的 sar 就是向右算数移位 1 位，ecx 变成 7。加上 esi 不变。将 ecx（7）与 edi（第一个输入）比较，如果大于，跳转。\n第一个输入小于 7，跳转到400fc1，将 edx 设置为 rcx 减去 1（6），递归调用自身 第一个输入大于等于 7，没有跳转，eax 变成 0，比较 ecx（7）与 edi，此时一定小于等于 小于时跳转400fcd，将 esi 设置为 rcx+1，即 8，递归调用 输入等于 7，不跳转，将栈指针增大，返回 为了方便看，将所有变量前面的 e 或者 r 隐藏：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func4(int dx = 14, int si = 0, int di = 第一个输入) { int ax = dx - si; int cx = ax \u0026gt;\u0026gt; 31 + ax; cx = cx \u0026gt;\u0026gt; 1; cx += si; // cx = (dx-si的符号位 + dx-si) / 2 + si if (cx \u0026gt; di) { dx = cx - 1; func4(dx, si, di); // 这里的 esi 与 edi 与输入的值一样，edx不同 ax *= 2; return; } else { ax = 0; if (cx \u0026lt; di) { si = cx + 1; func4 (dx, si, di); ax = 2 * ax + 1; return; } else { return; } } } 我们希望运行这个函数后，ax 的值为 3 。\n直接分析很难，尝试倒推。ax 有几个地方会被修改：\n进入函数，ax 设置为 dx - si 当修改后的 cx \u0026lt;= di 时，ax 设置为 0 之后如果 cx \u0026lt; di，调用函数后，ax 设置为 2 * ax + 1 也可以发现，函数中 di 仅仅会在判断的时候用到，永远不会被修改。并且判断分为三种可能，也就是 cx 与 di 的大小关系，其中 cx 为 (dx-si -(dx-si) 的符号位 ) / 2 + si，看起来是取 dx 与 si 的平均值。\n例如，一开始输入 dx 为 14，si 为 0，则 cx 为 7。ax 在函数开始初始化为两端之差。\n若均值大于 di，则 dx 变成 cx-1，也就是大端变成均值-1；然后递归调用，其中会改变 ax，最后返回 ax * 2 若均值小于 di，则 si 变成 cx+1，也就是小端变成均值+1；然后递归调用，其中会改变 ax，最后返回 ax * 2 + 1 如果均值等于 di，则直接返回，ax 为 0 这种形式很像二分法。我们希望最后的 ax 返回值为 3，是奇数，其倒推的过程应该是 0 -\u0026gt; (0 * 2 + 1 = 1) -\u0026gt; (1 * 2 + 1 = 3) 因此均值应该小于 di，也就是 di 大于 7 。\n调用函数过程中，ax 应该为 1 。在这个函数中，1 为奇数，因此其均值也应该小于 di，第二层递归。在第二层递归中，应该均值等于 di，直接返回 ax 为 0 。这样就可以构造出结果。\n[0, 14] 的均值为 7，di 大于 7 。[8, 14] 的均值为 11，di 应该大于 11。[12, 14] 的均值为 13。所以应该为 13。\n总之，第四阶段输入为：\n1 13 3 phase_5 开始时的 sscanf 前面还是 0x4025cf，调试发现还是将输入的两个数字，存到 rsp 所指的栈上，若输入个数小于 2 则爆炸。\n1 2 3 4 5 6 7 8 9 10 11 12 13 40106a:\tbe cf 25 40 00 mov $0x4025cf,%esi 40106f:\te8 2c fb ff ff callq 400ba0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 401074:\t83 f8 01 cmp $0x1,%eax 401077:\t7e 57 jle 4010d0 \u0026lt;phase_5+0x82\u0026gt; #输入个数小于2，爆炸 401079:\t8b 04 24 mov (%rsp),%eax # eax变成第一个输入 40107c:\t83 e0 0f and $0xf,%eax 40107f:\t89 04 24 mov %eax,(%rsp) 401082:\t83 f8 0f cmp $0xf,%eax 401085:\t74 2f je 4010b6 \u0026lt;phase_5+0x68\u0026gt; #爆炸 401087:\tb9 00 00 00 00 mov $0x0,%ecx 40108c:\tba 00 00 00 00 mov $0x0,%edx 401091:\t83 c2 01 add $0x1,%edx 401094:\t48 98 cltq 接着 eax 变成第一个输入，与 0xf 按位与运算，写入 rsp 第一个输入。如果 eax 等于 0xf，爆炸。然后 ecx 为 0，edx 为 1，并将 eax 拓展为 64 位。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 401091:\t83 c2 01 add $0x1,%edx # 😎 401094:\t48 98 cltq 401096:\t8b 04 85 80 24 40 00 mov 0x402480(,%rax,4),%eax 40109d:\t01 c1 add %eax,%ecx 40109f:\t83 f8 0f cmp $0xf,%eax 4010a2:\t75 ed jne 401091 \u0026lt;phase_5+0x43\u0026gt; # 跳转到 😎，循环计数 4010a4:\tc7 04 24 0f 00 00 00 movl $0xf,(%rsp) 4010ab:\t83 fa 03 cmp $0x3,%edx 4010ae:\t75 06 jne 4010b6 \u0026lt;phase_5+0x68\u0026gt; 4010b0:\t39 4c 24 04 cmp %ecx,0x4(%rsp) 4010b4:\t74 05 je 4010bb \u0026lt;phase_5+0x6d\u0026gt; 4010b6:\te8 8c 03 00 00 callq 401447 \u0026lt;explode_bomb\u0026gt; 4010bb:\t48 8b 44 24 08 mov 0x8(%rsp),%rax 4010c0:\t64 48 33 04 25 28 00 xor %fs:0x28,%rax 4010c7:\t00 00 4010c9:\t75 0c jne 4010d7 \u0026lt;phase_5+0x89\u0026gt; 4010cb:\t48 83 c4 18 add $0x18,%rsp 4010cf:\tc3 retq 4010d0:\te8 72 03 00 00 callq 401447 \u0026lt;explode_bomb\u0026gt; 4010d5:\teb a2 jmp 401079 \u0026lt;phase_5+0x2b\u0026gt; 4010d7:\te8 24 fa ff ff callq 400b00 \u0026lt;__stack_chk_fail@plt\u0026gt; 接下来会取 0x402480 开始的第 rax 的元素，尝试打印：\n1 2 3 4 5 6 pwndbg\u0026gt; x/20dw 0x402480 0x402480 \u0026lt;array.3415\u0026gt;: 10 2 14 7 0x402490 \u0026lt;array.3415+16\u0026gt;: 8 12 15 11 0x4024a0 \u0026lt;array.3415+32\u0026gt;: 0 4 1 13 0x4024b0 \u0026lt;array.3415+48\u0026gt;: 3 9 6 5 0x4024c0: 2032168787 1948284271 1802398056 1970239776 发现这是一个大小为 16 的数组，这也说明了之前为什么要限制 eax 为 0 到 15 之间的数：\n1 2 3 4 10 2 14 7 8 12 15 11 0 4 1 13 3 9 6 5 其索引与数组元素的对应关系如下：\n0 1 2 3 4 5 6 7 10 2 14 7 8 12 15 11 8 9 10 11 12 13 14 15 0 4 1 13 3 9 6 5 取其中第 rax 的元素放入 eax，将 ecx 加上 eax。判断 eax 与 0xf（15） 的关系，如果不相等，跳转回 0x401091。期间对 edx 不断加 1，ecx 不断加上 eax。\n画出其跳转关系：\n0 -\u0026gt; 10 -\u0026gt; 1 -\u0026gt; 2 -\u0026gt; 14 -\u0026gt; 6 -\u0026gt; 15 -\u0026gt; 5 -\u0026gt; 12 -\u0026gt; 3 -\u0026gt; 7 -\u0026gt; 11 -\u0026gt; 13 -\u0026gt; 9 -\u0026gt; 4 -\u0026gt; 8 -\u0026gt; 0，然后循环。可以知道当变成 15 的时候终止，所以可以改变终点：\n5 -\u0026gt; 12 -\u0026gt; 3 -\u0026gt; 7 -\u0026gt; 11 -\u0026gt; 13 -\u0026gt; 9 -\u0026gt; 4 -\u0026gt; 8 -\u0026gt; 0 -\u0026gt; 10 -\u0026gt; 1 -\u0026gt; 2 -\u0026gt; 14 -\u0026gt; 6 -\u0026gt; 15 循环结束后，将 15 写入 rsp 指向的元素，也就是第一个输入改为 15 。然后将 edx 与 3 进行比较，如果不为 3，跳转并爆炸。\n这说明循环需要进行 3 次。例如，我的尝试中输入为 13 14，在 0x4010a4 打上断点，发现此时 edx 为 0xa(10)，刚好是上面的链条中 13 到最后 15 的距离。\n因此，第一个输入应该是 2，或者 2 + 16n，其中 n 为自然数。\n之后，将 ecx 与第二个输入比较，如果不相等，爆炸。已知 ecx 是累计的数字的和，可知其为 14 + 6 + 15 = 35。\n总之，输入可以是如下的数：\n1 2 3 4 2 35 18 35 34 35 ... phase_6 首先将多个 caller-saved 的寄存器推入栈：\n1 2 3 4 5 6 0000000004010dc \u0026lt;phase_6\u0026gt;: 4010dc:\t41 56 push %r14 4010de:\t41 55 push %r13 4010e0:\t41 54 push %r12 4010e2:\t55 push %rbp 4010e3:\t53 push %rbx 接着是金丝雀数的一些操作（参考1），此处略。\n然后将 eax 清零，rsp 放入第二个参数 rsi，调用 read_six_numbers。\n1 2 3 4 5 6 7 4010f6:\t31 c0 xor %eax,%eax 4010f8:\t48 89 e6 mov %rsp,%rsi 4010fb:\te8 69 03 00 00 callq 401469 \u0026lt;read_six_numbers\u0026gt; 401100:\t49 89 e4 mov %rsp,%r12 401103:\t49 89 e5 mov %rsp,%r13 401106:\t41 be 00 00 00 00 mov $0x0,%r14d 40110c:\teb 25 jmp 401133 \u0026lt;phase_6+0x57\u0026gt; 回顾之前的 read_six_numbers 函数，可知第一个参数 dsi 是我们的输入字符串的地址，例如此处我的输入为 2 3 4 5 6 7，第二个参数 rsi 是当前 rsp 的地址。\n调用 read_six_numbers 后，打印当前 rsp 对应的量：\n1 2 3 pwndbg\u0026gt; x/6dw $rsp 0x7fffffffd9f0: 2 3 4 5 0x7fffffffda00: 6 7 可知我们输入的六个数都存在了栈上。然后函数更改一些寄存器，跳到 0x401133。\n1 2 3 4 5 6 7 8 9 10 401133:\t4c 89 ed mov %r13,%rbp 401136:\t41 8b 45 00 mov 0x0(%r13),%eax 40113a:\t83 e8 01 sub $0x1,%eax 40113d:\t83 f8 05 cmp $0x5,%eax 401140:\t77 cc ja 40110e \u0026lt;phase_6+0x32\u0026gt; # 爆炸 401142:\t41 83 c6 01 add $0x1,%r14d 401146:\t41 83 fe 06 cmp $0x6,%r14d 40114a:\t74 05 je 401151 \u0026lt;phase_6+0x75\u0026gt; 40114c:\t44 89 f3 mov %r14d,%ebx 40114f:\teb cc jmp 40111d \u0026lt;phase_6+0x41\u0026gt; 将第一个输入放入 eax，与 5 比较，如果大于，爆炸。r14 之前初始化为 0 。现在加上 1，与 6 比较，如果相等，跳到 0x401151 结束循环；否则将 r14 移到 ebx 中，跳到 40111d。\n1 2 3 4 5 6 7 8 401115:\t83 c3 01 add $0x1,%ebx 401118:\t83 fb 05 cmp $0x5,%ebx 40111b:\t7f 12 jg 40112f \u0026lt;phase_6+0x53\u0026gt; 40111d:\t48 63 c3 movslq %ebx,%rax # 刚刚跳转的位置 401120:\t8b 04 84 mov (%rsp,%rax,4),%eax 401123:\t39 45 00 cmp %eax,0x0(%rbp) 401126:\t75 ed jne 401115 \u0026lt;phase_6+0x39\u0026gt; 401128:\te8 1a 03 00 00 callq 401447 \u0026lt;explode_bomb\u0026gt; 将 ebx 移入 rax，rsp 中第 rax 个元素放入 eax。第一次来到这里时 ebx 为 1，所以这就是取第二个输入，例如我的是 3。目前 rbp 指向元素就是第一个元素，所以比较第二个元素与第一个是否相等。如果相等，就直接爆炸。否则跳转到 401115，增加 ebx，与 5 比较，如果大于，跳转到 40112f，这会给 rsp 指向的地址加 4，也就是指向下一个元素。\n利用调试器，多看几次流程。会发现其本质就是检查输入的 6 个数中第 i 个元素与第 j 个元素是否相等，如果相等就会触发爆炸。然后每次循环后增加 i 索引。同时，也会讲当前第 i 个元素减 1 后与 5 比较，如果大于，也会爆炸。说明当前元素应该小于等于 6 。\n因此，我们尝试输入 1 2 3 4 5 6，为 0x401151 打断点，跳转。\n1 2 3 4 5 6 7 8 9 10 401151:\t49 8d 4c 24 18 lea 0x18(%r12),%rcx 401156:\tba 07 00 00 00 mov $0x7,%edx 40115b:\t89 d0 mov %edx,%eax 40115d:\t41 2b 04 24 sub (%r12),%eax 401161:\t41 89 04 24 mov %eax,(%r12) 401165:\t49 83 c4 04 add $0x4,%r12 401169:\t4c 39 e1 cmp %r12,%rcx 40116c:\t75 ed jne 40115b \u0026lt;phase_6+0x7f\u0026gt; 40116e:\tbe 00 00 00 00 mov $0x0,%esi 401173:\teb 1a jmp 40118f \u0026lt;phase_6+0xb3\u0026gt; 首先将输入字符串的指针的地址（在栈上）写入 rcx。edx 与 eax 设为 7，将 7 - 第一个输入 写入第一个输入。然后增加 r12 指针指向下一个元素，直到指向尽头（rcx），否则跳转到 0x40115b 重复操作。总之，就是数组每个元素都变成 7-自身，因此现在我的数组变成了 6 5 4 3 2 1。将 esi 变成 0，跳转到 0x40118f 。\n1 2 3 4 5 6 40118f:\t8b 0c b4 mov (%rsp,%rsi,4),%ecx 401192:\tb8 01 00 00 00 mov $0x1,%eax 401197:\tba d0 32 60 00 mov $0x6032d0,%edx 40119c:\t83 f9 01 cmp $0x1,%ecx 40119f:\t7f d4 jg 401175 \u0026lt;phase_6+0x99\u0026gt; 4011a1:\teb dd jmp 401180 \u0026lt;phase_6+0xa4\u0026gt; 将 rsp[rsi] 放入 ecx，eax 写入 1，edx 是一个地址，然后 rsp[rsi] 与 1 比较。如果大于，跳转到 0x401175，否则跳转到 0x401180。尝试打印 edx：\n1 2 3 4 pwndbg\u0026gt; x/12xw 0x6032d0 0x6032d0 \u0026lt;node1\u0026gt;: 0x0000027a 0x00000001 0x006032e0 0x00000000 0x6032e0 \u0026lt;node2\u0026gt;: 0x00000353 0x00000002 0x006032f0 0x00000000 0x6032f0 \u0026lt;node3\u0026gt;: 0x00000399 0x00000003 0x00603300 0x00000000 可以看到这是一个类似链表的结构—— node1 中 0x006032e0 指向下一个的地址 0x006032e0，以此类推。我们看看一共有多少：\n1 2 3 4 5 6 7 8 pwndbg\u0026gt; x/28xw 0x6032d0 0x6032d0 \u0026lt;node1\u0026gt;: 0x0000027a 0x00000001 0x006032e0 0x00000000 0x6032e0 \u0026lt;node2\u0026gt;: 0x00000353 0x00000002 0x006032f0 0x00000000 0x6032f0 \u0026lt;node3\u0026gt;: 0x00000399 0x00000003 0x00603300 0x00000000 0x603300 \u0026lt;node4\u0026gt;: 0x00000136 0x00000004 0x00603310 0x00000000 0x603310 \u0026lt;node5\u0026gt;: 0x00000249 0x00000005 0x00603320 0x00000000 0x603320 \u0026lt;node6\u0026gt;: 0x0000008a 0x00000006 0x00000000 0x00000000 0x603330 \u0026lt;bomb_id\u0026gt;: 0x000007e6 0x00000000 0x00000000 0x00000000 可以看到刚好有 6 个，并且其中数字部分就是 1 2 3 4 5 6 。尝试更换我们的输入，我们发现这些链表的值与我们的输入是无关的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Good work! On to the next... 6 5 4 3 2 1 Breakpoint 1, 0x00000000004010dc in phase_6 () pwndbg\u0026gt; c Continuing. Breakpoint 2, 0x0000000000401151 in phase_6 () pwndbg\u0026gt; c Continuing. Breakpoint 3, 0x0000000000401197 in phase_6 () pwndbg\u0026gt; x/28xw 0x6032d0 0x6032d0 \u0026lt;node1\u0026gt;: 0x0000027a 0x00000001 0x006032e0 0x00000000 0x6032e0 \u0026lt;node2\u0026gt;: 0x00000353 0x00000002 0x006032f0 0x00000000 0x6032f0 \u0026lt;node3\u0026gt;: 0x00000399 0x00000003 0x00603300 0x00000000 0x603300 \u0026lt;node4\u0026gt;: 0x00000136 0x00000004 0x00603310 0x00000000 0x603310 \u0026lt;node5\u0026gt;: 0x00000249 0x00000005 0x00603320 0x00000000 0x603320 \u0026lt;node6\u0026gt;: 0x0000008a 0x00000006 0x00000000 0x00000000 0x603330 \u0026lt;bomb_id\u0026gt;: 0x000007e6 0x00000000 0x00000000 0x00000000 换回 1 2 3 4 5 6 的输入。我这里 rsp[rsi] 是 5，所以大于，跳转到 0x401175。\n1 2 3 4 5 6 7 8 401175:\t48 8b 52 08 mov 0x8(%rdx),%rdx 401179:\t83 c0 01 add $0x1,%eax 40117c:\t39 c8 cmp %ecx,%eax 40117e:\t75 f5 jne 401175 \u0026lt;phase_6+0x99\u0026gt; 401180:\t48 89 54 f4 20 mov %rdx,0x20(%rsp,%rsi,8) 401185:\t48 83 c6 01 add $0x1,%rsi 401189:\t48 83 fe 06 cmp $0x6,%rsi 40118d:\t74 14 je 4011a3 \u0026lt;phase_6+0xc7\u0026gt; 这一段不断增加 rdx，也就是寻找下一个链表元素，并且计数到 eax 中。记住 ecx 是 rsp[rsi] ，所以就相当于是取这个链表的第 rsp[rsi] 个元素，rdx 就指向该元素。\n然后将链表的第 rsp[rsi] 个元素的地址放入栈中。结束循环，现在的栈如下：\n1 2 3 4 5 6 7 8 9 10 11 00:0000│ rsp 0x7fffffffd9f0 ◂— 0x500000006 01:0008│-00c 0x7fffffffd9f8 ◂— 0x300000004 02:0010│ r13-4 rbp-4 0x7fffffffda00 ◂— 0x100000002 03:0018│ r12 0x7fffffffda08 —▸ 0x603910 (input_strings+400) ◂— \u0026#39;1 2 3 4 5 6\u0026#39; 04:0020│+00c 0x7fffffffda10 —▸ 0x603320 (node6) ◂— 0x60000008a 05:0028│+014 0x7fffffffda18 —▸ 0x603310 (node5) ◂— 0x500000249 06:0030│+01c 0x7fffffffda20 —▸ 0x603300 (node4) ◂— 0x400000136 07:0038│+024 0x7fffffffda28 —▸ 0x6032f0 (node3) ◂— 0x300000399 08:0040│+02c 0x7fffffffda30 —▸ 0x6032e0 (node2) ◂— 0x200000353 09:0048│+034 0x7fffffffda38 —▸ 0x6032d0 (node1) ◂— 0x10000027a 0a:0050│+03c 0x7fffffffda40 ◂— 0 可以看到栈中 00 到 02 存储的是输入数字，已经经过被7减处理了，原本是 1 2 3 4 5 6，现在是 6 5 4 3 2 1。03 存储的是输入字符串的指针。04 到 09 存储的是链表节点的指针，顺序是根据处理后的输入决定的。\n例如，输入 2 4 5 3 1 6，处理后变成 5 3 2 4 5 1，内存如下：\n1 2 3 4 5 6 04:0020│+00c 0x7fffffffda10 —▸ 0x603310 (node5) ◂— 0x500000249 05:0028│+014 0x7fffffffda18 —▸ 0x6032f0 (node3) ◂— 0x300000399 06:0030│+01c 0x7fffffffda20 —▸ 0x6032e0 (node2) ◂— 0x200000353 07:0038│+024 0x7fffffffda28 —▸ 0x603300 (node4) ◂— 0x400000136 08:0040│+02c 0x7fffffffda30 —▸ 0x603320 (node6) ◂— 0x60000008a 09:0048│+034 0x7fffffffda38 —▸ 0x6032d0 (node1) ◂— 0x10000027a 可以看到这里链表指针的顺序就与我们的输入有关。\n接下来又是许多代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 4011a3:\t48 8b 5c 24 20 mov 0x20(%rsp),%rbx 4011a8:\t48 8b 44 24 28 mov 0x28(%rsp),%rax 4011ad:\t48 89 43 08 mov %rax,0x8(%rbx) 4011b1:\t48 8b 54 24 30 mov 0x30(%rsp),%rdx 4011b6:\t48 89 50 08 mov %rdx,0x8(%rax) 4011ba:\t48 8b 44 24 38 mov 0x38(%rsp),%rax 4011bf:\t48 89 42 08 mov %rax,0x8(%rdx) 4011c3:\t48 8b 54 24 40 mov 0x40(%rsp),%rdx 4011c8:\t48 89 50 08 mov %rdx,0x8(%rax) 4011cc:\t48 8b 44 24 48 mov 0x48(%rsp),%rax 4011d1:\t48 89 42 08 mov %rax,0x8(%rdx) 4011d5:\t48 c7 40 08 00 00 00 movq $0x0,0x8(%rax) 4011dc:\t00 4011dc:\t00 4011dd:\tbd 05 00 00 00 mov $0x5,%ebp 4011e2:\teb 09 jmp 4011ed \u0026lt;phase_6+0x111\u0026gt; 还是先将输入变回 1 2 3 4 5 6，然后会发现这串代码会改变链表的顺序。原始顺序：\n1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; 6\n在存放顺序是 6 5 4 3 2 1 的情况下，这些操作的结果如下（我省略了其他代码的结果）：\n1 2 3 4 5 6 0x4011ad \u0026lt;phase_6+209\u0026gt; movq %rax, 8(%rbx) [node6+8] =\u0026gt; 0x603310 (node5) ◂— 0x500000249 0x4011b6 \u0026lt;phase_6+218\u0026gt; movq %rdx, 8(%rax) [node5+8] =\u0026gt; 0x603300 (node4) ◂— 0x400000136 0x4011bf \u0026lt;phase_6+227\u0026gt; movq %rax, 8(%rdx) [node4+8] =\u0026gt; 0x6032f0 (node3) ◂— 0x300000399 0x4011c8 \u0026lt;phase_6+236\u0026gt; movq %rdx, 8(%rax) [node3+8] =\u0026gt; 0x6032e0 (node2) ◂— 0x200000353 0x4011d1 \u0026lt;phase_6+245\u0026gt; movq %rax, 8(%rdx) [node2+8] =\u0026gt; 0x6032d0 (node1) ◂— 0x10000027a 0x4011d5 \u0026lt;phase_6+249\u0026gt; movq $0, 8(%rax) [node1+8] =\u0026gt; 0 再次打印，发现顺序发生变化：\n1 2 3 4 5 6 7 8 pwndbg\u0026gt; x/28xw 0x6032d0 0x6032d0 \u0026lt;node1\u0026gt;: 0x0000027a 0x00000001 0x00000000 0x00000000 0x6032e0 \u0026lt;node2\u0026gt;: 0x00000353 0x00000002 0x006032d0 0x00000000 0x6032f0 \u0026lt;node3\u0026gt;: 0x00000399 0x00000003 0x006032e0 0x00000000 0x603300 \u0026lt;node4\u0026gt;: 0x00000136 0x00000004 0x006032f0 0x00000000 0x603310 \u0026lt;node5\u0026gt;: 0x00000249 0x00000005 0x00603300 0x00000000 0x603320 \u0026lt;node6\u0026gt;: 0x0000008a 0x00000006 0x00603310 0x00000000 0x603330 \u0026lt;bomb_id\u0026gt;: 0x000007e6 0x00000000 0x00000000 0x00000000 6 -\u0026gt; 5 -\u0026gt; 4 -\u0026gt; 3 -\u0026gt; 2 -\u0026gt; 1 -\u0026gt; NaN\n所以，该函数的功能就是根据栈中存放的顺序，重新调整链表节点的顺序。例如输入 1 2 3 4 5 6，存放到栈中为 6 5 4 3 2 1 ，于是链表顺序变成 6 5 4 3 2 1。\n尝试输入 5 3 1 2 6 4 ，存放到栈中为 2 4 6 5 1 3，链表顺序为 2 4 6 5 1 3。\n接着跳转到 0x4011ed，将 rbx 指向的下一个节点地址放入 rax，将该下一个节点的值放入 eax，让 rbx 指向的节点的值与该值比较。如果大于等于，跳转；否则爆炸。\n1 2 3 4 5 4011ed:\t48 8b 43 08 mov 0x8(%rbx),%rax 4011f1:\t8b 00 mov (%rax),%eax 4011f3:\t39 03 cmp %eax,(%rbx) 4011f5:\t7d ed jge 4011e4 \u0026lt;phase_6+0x108\u0026gt; 4011f7:\te8 4b 02 00 00 callq 401447 \u0026lt;explode_bomb\u0026gt; 想要跳出循环，需要在上面满足该条件，也就是 ebp 等于 0。而 ebp 一开始为 5，说明会进行遍历操作。\n1 2 3 4011e4:\t48 8b 5b 08 mov 0x8(%rbx),%rbx 4011e8:\t83 ed 01 sub $0x1,%ebp 4011eb:\t74 11 je 4011fe \u0026lt;phase_6+0x122\u0026gt; 若此处跳转，就可以结束了。所以，我们的目标明确了起来——找到一组 1-6 的顺序，可以调整链表的连接顺序，进而满足最后的每个节点大于另一个节点的条件。\n观察原始链表中的大小，可以得到正确的排序：\n链表 id 值 3 0x399 2 0x353 1 0x27a 5 0x249 4 0x136 6 0x08a 也就是处理后为 3 2 1 5 4 6，处理前为 4 5 6 2 3 1。第六阶段密码为 4 5 6 2 3 1。\n结束了？ 翻一下汇编，我们会发现一个神秘的函数 fun7，它会在 secret_phase 中被调用。搜索 secret_phase，发现它隐藏在 phase_defused 中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 00000000004015d6 \u0026lt;phase_defused\u0026gt;: 4015d6:\t48 83 ec 78 sub $0x78,%rsp 4015da:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax 4015e1:\t00 00 4015e3:\t48 89 44 24 68 mov %rax,0x68(%rsp) 4015e8:\t31 c0 xor %eax,%eax 4015ea:\t83 3d 7b 21 20 00 06 cmpl $0x6,0x20217b(%rip) # 60376c \u0026lt;num_input_strings\u0026gt; 4015f1:\t74 15 je 401608 \u0026lt;phase_defused+0x32\u0026gt; 4015f3:\t48 8b 44 24 68 mov 0x68(%rsp),%rax 4015f8:\t64 48 33 04 25 28 00 xor %fs:0x28,%rax 4015ff:\t00 00 401601:\t75 67 jne 40166a \u0026lt;phase_defused+0x94\u0026gt; 401603:\t48 83 c4 78 add $0x78,%rsp 401607:\tc3 retq 发现其中要想进入隐藏阶段，必须满足 cmpl $0x6,0x20217b(%rip)，这就是 num_input_strings 的地址。在 read_line 中，每次读取一行的输入，都会将该变量加一。所以这一行代表着结束第六阶段后才能解锁。\n1 2 3 4 5 6 7 8 401608:\t4c 8d 44 24 10 lea 0x10(%rsp),%r8 40160d:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx 401612:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx 401617:\tbe 19 26 40 00 mov $0x402619,%esi 40161c:\tbf 70 38 60 00 mov $0x603870,%edi 401621:\te8 7a f5 ff ff callq 400ba0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 401626:\t83 f8 03 cmp $0x3,%eax 401629:\t74 0c je 401637 \u0026lt;phase_defused+0x61\u0026gt; 调试可以发现，该 sscanf 的输入是 input_strings+240，也就是第四阶段输入的字符串，例如我的是 13 3。匹配的格式是 %d %d %s，说明需要额外输入一个字符串。\n尝试改变第四阶段输入为 13 3 hello，进入 0x401637 ：\n1 2 3 4 5 6 7 8 9 10 11 401637:\tbe 22 26 40 00 mov $0x402622,%esi 40163c:\t48 8d 7c 24 10 lea 0x10(%rsp),%rdi 401641:\te8 04 fd ff ff callq 40134a \u0026lt;strings_not_equal\u0026gt; 401646:\t85 c0 test %eax,%eax 401648:\t75 e1 jne 40162b \u0026lt;phase_defused+0x55\u0026gt; 40164a:\tbf f8 24 40 00 mov $0x4024f8,%edi 40164f:\te8 8c f4 ff ff callq 400ae0 \u0026lt;puts@plt\u0026gt; 401654:\tbf 20 25 40 00 mov $0x402520,%edi 401659:\te8 82 f4 ff ff callq 400ae0 \u0026lt;puts@plt\u0026gt; 40165e:\tb8 00 00 00 00 mov $0x0,%eax 401663:\te8 f7 fb ff ff callq 40125f \u0026lt;secret_phase\u0026gt; 发现 esi 为字符串 urxvt，然后调用字符串匹配。因此我们修改输入为 13 3 urxvt，成功进入隐藏阶段。\n一开始就要输入，然后调用 strtol 将字符串转换为 long。接着返回值移入 rbx，eax 变成输入的数减一，与 0x3e8 (1000) 比较，如果大于，爆炸。因此我们尝试输入 987。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 00000000040125f \u0026lt;secret_phase\u0026gt;: 40125f:\t53 push %rbx 401260:\te8 43 02 00 00 callq 4014a8 \u0026lt;read_line\u0026gt; 401265:\tba 0a 00 00 00 mov $0xa,%edx 40126a:\tbe 00 00 00 00 mov $0x0,%esi 40126f:\t48 89 c7 mov %rax,%rdi 401272:\te8 09 f9 ff ff callq 400b80 \u0026lt;strtol@plt\u0026gt; 401277:\t48 89 c3 mov %rax,%rbx 40127a:\t8d 40 ff lea -0x1(%rax),%eax 40127d:\t3d e8 03 00 00 cmp $0x3e8,%eax 401282:\t77 27 ja 4012ab \u0026lt;secret_phase+0x4c\u0026gt; 401284:\t89 de mov %ebx,%esi 401286:\tbf f0 30 60 00 mov $0x6030f0,%edi 40128b:\te8 90 ff ff ff callq 401220 \u0026lt;fun7\u0026gt; 接下来调用函数 fun7，第一个参数为 0x6030f0，第二个参数为我们输入的数。可以发现我们希望这个函数的返回值是 4，这就是最终目标。\n1 2 3 4 5 6 0000000000401220 \u0026lt;fun7\u0026gt;: 401220:\t48 85 ff test %rdi,%rdi 401223:\t74 34 je 401259 \u0026lt;fun7+0x39\u0026gt; ... 401259:\tb8 ff ff ff ff mov $0xffffffff,%eax 40125e:\tc3 retq 首先判断 rdi 不为 0，否则直接返回 -1 。\n然后将 rdi 指向的值放入 edx，这里的值是 0x24，判断与我们输入数的关系。\n如果输入大于 edx，不跳转，eax 写入 0，跳转到 40124a。将 rdi 后面隔 16 个字节的中数写入 rdi，递归调用 如果输入小于等于 edx，跳转，将 rdi 后面隔 8 个字节中的数写入 rdi，递归调用 打印这些值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 pwndbg\u0026gt; x/64xg $rdi 0x6030f0 \u0026lt;n1\u0026gt;: 0x0000000000000024 0x0000000000603110 \u0026lt;n21\u0026gt; 0x603100 \u0026lt;n1+16\u0026gt;: 0x0000000000603130 \u0026lt;n22\u0026gt; 0x0000000000000000 0x603110 \u0026lt;n21\u0026gt;: 0x0000000000000008 0x0000000000603190 \u0026lt;n31\u0026gt; 0x603120 \u0026lt;n21+16\u0026gt;: 0x0000000000603150 \u0026lt;n32\u0026gt; 0x0000000000000000 0x603130 \u0026lt;n22\u0026gt;: 0x0000000000000032 0x0000000000603170 \u0026lt;n33\u0026gt; 0x603140 \u0026lt;n22+16\u0026gt;: 0x00000000006031b0 \u0026lt;n34\u0026gt; 0x0000000000000000 0x603150 \u0026lt;n32\u0026gt;: 0x0000000000000016 0x0000000000603270 \u0026lt;n43\u0026gt; 0x603160 \u0026lt;n32+16\u0026gt;: 0x0000000000603230 \u0026lt;n44\u0026gt; 0x0000000000000000 0x603170 \u0026lt;n33\u0026gt;: 0x000000000000002d 0x00000000006031d0 \u0026lt;n45\u0026gt; 0x603180 \u0026lt;n33+16\u0026gt;: 0x0000000000603290 \u0026lt;n46\u0026gt; 0x0000000000000000 0x603190 \u0026lt;n31\u0026gt;: 0x0000000000000006 0x00000000006031f0 \u0026lt;n41\u0026gt; 0x6031a0 \u0026lt;n31+16\u0026gt;: 0x0000000000603250 \u0026lt;n42\u0026gt; 0x0000000000000000 0x6031b0 \u0026lt;n34\u0026gt;: 0x000000000000006b 0x0000000000603210 \u0026lt;n47\u0026gt; 0x6031c0 \u0026lt;n34+16\u0026gt;: 0x00000000006032b0 \u0026lt;n48\u0026gt; 0x0000000000000000 0x6031d0 \u0026lt;n45\u0026gt;: 0x0000000000000028 0x0000000000000000 0x6031e0 \u0026lt;n45+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x6031f0 \u0026lt;n41\u0026gt;: 0x0000000000000001 0x0000000000000000 0x603200 \u0026lt;n41+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x603210 \u0026lt;n47\u0026gt;: 0x0000000000000063 0x0000000000000000 0x603220 \u0026lt;n47+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x603230 \u0026lt;n44\u0026gt;: 0x0000000000000023 0x0000000000000000 0x603240 \u0026lt;n44+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x603250 \u0026lt;n42\u0026gt;: 0x0000000000000007 0x0000000000000000 0x603260 \u0026lt;n42+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x603270 \u0026lt;n43\u0026gt;: 0x0000000000000014 0x0000000000000000 0x603280 \u0026lt;n43+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x603290 \u0026lt;n46\u0026gt;: 0x000000000000002f 0x0000000000000000 0x6032a0 \u0026lt;n46+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x6032b0 \u0026lt;n48\u0026gt;: 0x00000000000003e9 0x0000000000000000 0x6032c0 \u0026lt;n48+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x6032d0 \u0026lt;node1\u0026gt;: 0x000000010000027a 0x0000000000603310 0x6032e0 \u0026lt;node2\u0026gt;: 0x0000000200000353 0x00000000006032d0 这些节点的相互引用关系如图：\n不断调用，可以发现当 rdi 指向 n48 时，n48 中的值为 3e9 (1001)，必定大于我们的输入。此时结束，跳转到 0x40123d，此时会取 rdi 指向位置的后 8 个字节，放入 rdi（与之前的 16 字节不同！）。不过现在 n48 对应的这个值为 0 。再次递归调用。这时候因为 rdi 参数为 0，所以将 -1 写入 eax，返回。\n8 字节情况返回 401246：eax = eax + eax，例如我这里变成了-2 16 字节情况返回 401253：eax = rax + rax + 1，例如我这里有几个状态： -2 + -2 + 1 = -3 -3 + -3 + 1 = -5 -5 + -5 + 1 = -9 最终在 987 输入的情况下，返回为 -9 于是，当时让我迷惑的事情来了：secret_phase 中希望我们最后得到的返回值是整数 4，这怎么做到呢？\n尝试输入 1 调试，发现当输入的数恰好等于叶子结点时，就会停止递归调用。此时会运行 0x40122f ，将 eax 变成 0 。所以，从反向推导，要得到 4 应该是这样的：\n0 -\u0026gt; 2 * 0 + 1 = 1 -\u0026gt; 1 * 2 = 2 -\u0026gt; 2 * 2 = 4\n反向过程先是一个大于，然后是两个小于等于。正向过程就是先两个小于等于，然后一个大于。\n参考图片：\n答案为 7 。\n总结 这个实验确实量大管饱，我差不多前前后后花了好几天时间才写完。\n对于此前没有接触过汇编的我来说，确实有些难度。还好借助了 GDB Dashboard、pwndbg 等强大的调试器，以及部分地方参考了 arthals 的北大 bomblab 博客1。自然有些细节上还是有差异的，并且该博客没有写 secret phase。\n经过这样的折腾，确实感觉自己对汇编的掌握更加深入。也让我想起了很久之前手挫 cs61b 的 gitlet 的快感（）\n该指南很多地方都是我做 lab 的时候，边想边写的，所以语句可能不通顺，也不是最适合理解的顺序。该指南只记录了我解题中的一些思考过程。如果能在某个卡点帮到你，有所启发，那么我的目的就达成了。\n参考资料 更适合北大宝宝体质的 Bomb Lab 踩坑记. https://arthals.ink/blog/bomb-lab\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nsscanf. cplusplus. https://cplusplus.com/reference/cstdio/sscanf\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-10-22T00:00:00Z","image":"https://ovideros.site/p/csapp_bomblab/tree2_hu_e27691f64c54bc36.jpeg","permalink":"https://ovideros.site/p/csapp_bomblab/","title":"💣 CSAPP BombLab 实验指南"},{"content":"前言 之前我写了 GDB Dashboard 教程 ，文末提到了 pwndbg，今天详细讲述一下。\npwndbg 是一个支持 GDB1 或者 LLDB2 的插件，便于汇编级别的软件开发者、逆向工程师等3。本文主要探讨其对于 CSAPP Labs 的作用，以及相应的自定义配置。\n传统的 GDB 或 LLDB 很难逆向工程，总是要手动输入大量指令，查看内存信息，例如输入 x/30gx $rsp 来查看 rsp 指向的栈。在当今时代，这并不高效。Pwndbg 是基于 Python 的模组，可以加载进 GDB 或者 LLDB，进而方便查看内存细节。\n预备知识 了解 GDB，掌握 Linux 环境与命令行基础，了解 Git 使用方法。本文环境都基于 Ubuntu。\n下载与安装 虽然官方文档提供了许多方法4，但是在我这总遇到一些环境问题，可能因为我使用的是 Ubuntu20.04，版本较老。后面发现克隆 Github 仓库并运行脚本更方便。\n首先，克隆官方的 Github 仓库。如果较慢，可以考虑换源、设置代理等，这里不展开。\n1 git clone https://github.com/pwndbg/pwndbg.git 如果你的系统版本较新，可以尝试直接安装：\n1 2 cd pwndbg ./setup.sh 但是，我会出现下面的报错：\n1 2 3 Your system has unsupported python version. Please use older pwndbg release: \u0026#39;git checkout 2024.08.29\u0026#39; - python3.8, python3.9 \u0026#39;git checkout 2023.07.17\u0026#39; - python3.6, python3.7 原因在于我的系统 python 较老。所以，首先切换到更早的版本，然后再运行安装脚本：\n1 2 git checkout 2024.08.29 ./setup.sh 这样就能正确安装。查看用户目录下的配置文件，即 ~/.gdbinit，发现它载入了环境，其中 \u0026lt;path to your github repo\u0026gt; 取决于你运行 git clone 时候的位置：\n1 2 source ~/.config/gdb/gdbinit # source /\u0026lt;path to your github repo\u0026gt;/gdbinit.py 为了方便每一次调试都自动启用 pwndbg，可以取消第二行的注释：\n1 2 source ~/.config/gdb/gdbinit source /home/ywr/dsc/learn/csapp/pwndbg/gdbinit.py 参考上一篇博客 GDB Dashboard 教程 ，这里的 ~/.config/gdb/gdbinit 应该设置了安全的路径：\n1 2 set auto-load local-gdbinit on add-auto-load-safe-path /\u0026lt;path to your working dir\u0026gt;/ 或者是全部目录：\n1 2 set auto-load local-gdbinit on set auto-load safe-path / 这样，在相应的目录下，直接运行 gdb \u0026lt;program\u0026gt;，其中 program 为一个程序，就能进入 pwndbg 页面。\n1 2 # 各种信息 pwndbg\u0026gt; pwndbg+tmux 自定义配置 虽然说 Tabby 也自带分割终端的功能，但是它在分割后会自动降低非当前窗口的亮度，看起来有点奇怪。于是我改用 tmux5 了。\n简单来说，Ubuntu 系统下 tmux 可以通过 apt 来安装：\n1 2 sudo apt update sudo apt install tmux 然后，创建新的 tmux 会话：\n1 tmux new -s bomb 此处 bomb 可以是任意名字。这样会自动进入当前窗口。要想退出，可以按 Control + B 键，松开，再按 D 键。\n为了再次进入当前会话，输入：\n1 tmux a -t bomb 其中 bomb 是你刚刚取的名字。\n分割窗口，按 Control + B 键，松开，再按 % 键（Shift + 5），你会发现窗口分成了左右两块。并且该分割线是可以用鼠标拖动的，至少我在 Tabby 与 VSCode 终端中都可以。\n为了将调试信息都放到右边的窗口，我让 AI 帮我写了一段脚本，然后粘贴到 ~/.gdbinit 文件中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 # -------------------------------------------------------------------------- # Pwndbg: Custom command to redirect context panes to another TTY # This Python-based command correctly handles string arguments with special characters. # Usage: setupwin /dev/pts/X # -------------------------------------------------------------------------- python import gdb class SetupWin(gdb.Command): \u0026#34;\u0026#34;\u0026#34;Redirects Pwndbg context panes to a specified TTY.\u0026#34;\u0026#34;\u0026#34; def __init__(self): # Create the command \u0026#34;setupwin\u0026#34; in GDB super(SetupWin, self).__init__(\u0026#34;setupwin\u0026#34;, gdb.COMMAND_USER) def invoke(self, argument, from_tty): # This method is called when the user types \u0026#34;setupwin\u0026#34; if not argument: print(\u0026#34;Usage: setupwin /dev/pts/X\u0026#34;) return # The argument is passed as a single string, which we can parse safely tty_path = argument.strip() # List of panes you want to redirect (matches your config) panes_to_redirect = [\u0026#39;legend\u0026#39;, \u0026#39;code\u0026#39;, \u0026#39;stack\u0026#39;, \u0026#39;regs\u0026#39;, \u0026#39;disasm\u0026#39;, \u0026#39;backtrace\u0026#39;] # Use gdb.execute to run commands, building the command string in Python gdb.execute(\u0026#34;context off\u0026#34;) for pane in panes_to_redirect: # Safely construct the command string and execute it gdb.execute(f\u0026#34;contextoutput {pane} {tty_path} true\u0026#34;) gdb.execute(\u0026#34;context on\u0026#34;) print(f\u0026#34;Pwndbg context redirected to {tty_path}\u0026#34;) # Instantiate the class to register the command with GDB SetupWin() end # 这两行加载配置和pwndbg本身，保持不变 source ~/.config/gdb/gdbinit source /home/ywr/dsc/learn/csapp/pwndbg/gdbinit.py 这个脚本利用 Python 定义了 setupwin 函数，输入的参数是另一个要展示的窗口，然后将各个部分都放在另一个窗口上。\n用鼠标选择 tmux 中右侧窗口，输入 tty 打印信息，得到 /dev/pts/\u0026lt;num\u0026gt;，其中 num 数字因人而异。\n然后，可以在系统 ~/.gdbinit 中的末尾，或者当前工作目录的 .gdbinit 中，尾部加入这一行：\n1 setupwin /dev/pts/\u0026lt;num\u0026gt; 其中 \u0026lt;num\u0026gt; 是刚刚输出的数字。这样每次运行都会自动执行 setupwin 函数。\n然后为程序打上断点并运行，就得到了这样的画面：\n左侧可以输入命令，右侧有各种调试信息，包括寄存器、反汇编、栈等等。\npwndbg 调试信息讲解 初次看到 pwndbg 的调试信息可能有点蒙，感觉很多字。这正是因为其中的信息丰富。\nlegend 首先，最上方显示的 LEGEND，代表了不同颜色对应的内存区域，解释如下：\nSTACK：栈，存储局部变量与函数调用。 HEAP：堆，动态声明的内存。 CODE：代码区，储存可执行指令。 DATA：数据区，存储初始化的数据，如全局变量。 RODATA：只读代码区。 RWX：Readable, Writable, and eXecutable. 可以读、写、执行的代码区域。 registers 该区域存储着寄存器的信息。以上面的pwndbg+tmux分屏配置图片为例，rbx 寄存器信息如下：\n1 RBX 0x7fffffffdb78 —▸ 0x7fffffffdf4a ◂— \u0026#39;/home/ywr/dsc/learn/csapp/bomblab/bomb\u0026#39; 这当中内存是黄色高亮的，说明是栈区域。rbx 中存放的是 0x7fffffffdb78，这是一个地址，其指向的位置存放的是 0x7fffffffdf4a，这又是一个指针，指向一个字符串，其内容为 /home/ywr/dsc/learn/csapp/bomblab/bomb。\n不信的话，可以利用 gdb 命令打印出来：\n1 2 3 4 pwndbg\u0026gt; x/xg 0x7fffffffdb78 0x7fffffffdb78: 0x00007fffffffdf4a pwndbg\u0026gt; x/s 0x00007fffffffdf4a 0x7fffffffdf4a: \u0026#34;/home/ywr/dsc/learn/csapp/bomblab/bomb\u0026#34; 同理，下面的 rdi 与 rsi 存储的都是 0x4023d0 ，是红色，代表是代码区域。打印其中内容：\n1 2 pwndbg\u0026gt; x/s $rdi 0x4023d0: \u0026#34;Slave, thou hast slain me. Villain, take my purse.\u0026#34; 发现其指向的是一个字符串。\ndisarm 该区域存储着反汇编信息。注意，我这里显示的是 Intel 格式，而不是 AT\u0026amp;T 格式，后者是 CSAPP 的呈现方式。\n为了方便，可以设置：\n1 set disassembly-flavor att 将这一行写入 ~/.gdbinit 的文件末尾。这样就不用每次执行了。\n反汇编区域最左侧是指令地址，然后是相对于当前函数的地址，接着是操作符与操作数。\n在反汇编区域最右侧，会有该指令的效果，并且默认是开启模拟的，也就是会模拟之后的效果。但是我发现，这有时候会导致之前语句的结果是基于当前指令的，有些麻烦。所以我关掉了：\n1 set emulate off 你也会发现，对于跳转语句，pwndbg 不同与一般的 GDB，它会在到达这一行后，显示接下来跳转的行，方便你进行观察。\nstack 这里是 rsp 指向的栈区域，在 CSAPP 中也会频繁用到。其中的箭头，也都说明了其值以及引用关系。\n以下面的结果为例：\n1 2 00:0000│ rsp 0x7fffffffda00 ◂— 0x50 /* \u0026#39;P\u0026#39; */ 01:0008│ 0x7fffffffda08 —▸ 0x6037d0 (input_strings+80) ◂— \u0026#39;1 2 4 7 11 16\u0026#39; 记住栈顶拓展是从大到小的。当前 rsp 指向 0x7fffffffda00，其中内容为 0x50，也可以解释为字符 P 的 ASCII 码6。\n栈的下一个元素的地址为 0x7fffffffda08，其中存放着 0x6037d0，这是输入字符串的指针，字符串为 1 2 4 7 11 16。\n可以发现，pwndbg 确实相当方便，智能地解析了地址，免去了一遍遍输入指令查看。\nbacktrace 该区域记录了调用函数的信息，例如\n1 2 3 ► 0 0x4015e8 phase_defused+18 1 0x400da2 main+123 2 0x7ffff7c5d083 __libc_start_main+243 说明当前处在 phase_defused 函数中，该函数在 main 中调用，而 main 又在__libc_start_main 中被调用。\n我的自定义配置 为了方便查看更多信息，我还增大了反汇编与栈区域的行数，以及设置了 show-compact-regs 为 on 。\n我的具体配置如下：\n1 2 3 4 5 6 7 8 9 10 11 # 自定义的 SetupWin 函数，此处略 # 这两行加载配置和pwndbg本身，保持不变 source ~/.config/gdb/gdbinit source /home/ywr/dsc/learn/csapp/pwndbg/gdbinit.py set disassembly-flavor att set show-compact-regs on set context-disasm-lines 15 set context-stack-lines 15 set emulate off 将最后几行写入 ~/.gdbinit 即可。\n总结 本文讲述了如何在 Ubuntu 上安装并配置 pwndbg，希望能有所启发。\n参考资料 GNU Debugger. Wikipedia. https://en.wikipedia.org/wiki/GNU_Debugger\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLLDB. https://lldb.llvm.org/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\npwndbg. Github. https://github.com/pwndbg/pwndbg\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSetup. pwndbg documentation. https://pwndbg.re/pwndbg/latest/setup/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\ntmux Wiki. https://github.com/tmux/tmux\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nascii. Wikipedia. https://en.wikipedia.org/wiki/ASCII\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-10-22T00:00:00Z","image":"https://ovideros.site/p/pwndbg/front_hu_9664ff6adf2ae749.png","permalink":"https://ovideros.site/p/pwndbg/","title":"pwndbg 教程与自定义配置"},{"content":"因为要做 CSAPP 的一些实验，所以会接触到汇编级别调试。正如之前介绍 GDB Dashboard 的文章所说1，传统的 gdb -tui 虽然可以同时显示汇编与寄存器，但是版面不够美观，也很难对布局进行自定义。基于 VSCode + GDB 的方法虽然有现代化的UI，但是很难调试汇编程序。而 GDB Dashboard 解决了上述困扰。\nGDB Dashboard 2基于 Python，重构了 GDB 的页面，且高度支持自定义，相当美观，如图：\n我使用了 Tabby 终端，并且配置了左右两个窗口，左侧显示 GDB 指令，右侧显示信息。\n预备知识 了解 GDB，掌握 Linux 环境与命令行基础。本文环境都基于 Ubuntu。\n安装方法 GDB dashboard 本质上就是一个脚本，可以很方便地下载：\n1 wget -P ~ https://github.com/cyrus-and/gdb-dashboard/raw/master/.gdbinit 该命令会将.gdbinit下载到用户根目录~下面。\n要想在特定的目录使用 GDB dashboard，只需要将 .gdbinit 复制到对应路径即可。\n1 mv ~/.gdbinit your_target_dir/ 然后对 GDB 进行设置，确保载入 .gdbinit 。编辑 ~/.config/gdb/gdbinit 文件，在其中指定加载的地址：\n1 2 set auto-load local-gdbinit on add-auto-load-safe-path /home/ovideros/learn/csapp/bomblab 这最后一行中的路径是你需要使用 .gdbinit 的工作目录。如果为了省事，也可以设置为全部目录：\n1 2 set auto-load local-gdbinit on set auto-load safe-path / 打开下载的 .gdbinit，可以看到前几行如下：\n1 2 3 4 5 6 7 8 python # GDB dashboard - Modular visual interface for GDB in Python. # # https://github.com/cyrus-and/gdb-dashboard # License ---------------------------------------------------------------------- # ... 如果需要自定义 .gdbinit 设置，例如设定调试文件的输入参数，断点位置，都可以在 python 命令前面输入。\n现在运行 gdb ./program，就可以对 program 进行调试。输入 start，开启 GDB dashboard。\n如果你觉得每次输入 start 比较麻烦，也可以写入 .gdbinit：\n1 2 3 4 5 6 7 8 9 10 start python # GDB dashboard - Modular visual interface for GDB in Python. # # https://github.com/cyrus-and/gdb-dashboard # License ---------------------------------------------------------------------- # ... 这样每次运行 gdb ./program 都会默认打开 GDB dashboard 了。\n自定义配置 利用 help 默认的 GDB dashboard 可能不够美观，如图：\n主要是其中输入命令的部分过少，且包含一些我们不关心的内容。\n好在 GDB dashboard 是高度自定义的。如果不需要一些部分，可以直接输入进行取消。例如，不需要源代码 Source 部分，可以输入 dashboard source。\n为了获取各种命令，可以输入 help dashboard，输出如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026gt;\u0026gt;\u0026gt; help dashboard Redisplay the dashboard. List of dashboard subcommands: dashboard -configuration -- Dump or save the dashboard configuration. dashboard -enabled -- Enable or disable the dashboard. dashboard -layout -- Set or show the dashboard layout. dashboard -output -- Set the output file/TTY for the whole dashboard or single modules. dashboard -style -- Access the stylable attributes. dashboard assembly -- Configure the assembly module, with no arguments toggles its visibility. dashboard breakpoints -- Configure the breakpoints module, with no arguments toggles its visibility. dashboard expressions -- Configure the expressions module, with no arguments toggles its visibility. dashboard history -- Configure the history module, with no arguments toggles its visibility. dashboard memory -- Configure the memory module, with no arguments toggles its visibility. dashboard registers -- Configure the registers module, with no arguments toggles its visibility. dashboard source -- Configure the source module, with no arguments toggles its visibility. dashboard stack -- Configure the stack module, with no arguments toggles its visibility. dashboard threads -- Configure the threads module, with no arguments toggles its visibility. dashboard variables -- Configure the variables module, with no arguments toggles its visibility. Type \u0026#34;help dashboard\u0026#34; followed by dashboard subcommand name for full documentation. Type \u0026#34;apropos word\u0026#34; to search for commands related to \u0026#34;word\u0026#34;. Type \u0026#34;apropos -v word\u0026#34; for full documentation of commands related to \u0026#34;word\u0026#34;. Command name abbreviations are allowed if unambiguous. 之后需要详细了解哪一部分，也只需要更多地使用 help。例如，我想要知道 assembly 部分的详细设置，就可以输入 help dashboard assembly：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026gt;\u0026gt;\u0026gt; help dashboard assembly Configure the assembly module, with no arguments toggles its visibility. Show the disassembled code surrounding the program counter. The instructions constituting the current statement are marked, if available. List of dashboard assembly subcommands: dashboard assembly -output -- Set the output file/TTY for the whole dashboard or single modules. dashboard assembly -style -- Access the stylable attributes. dashboard assembly scroll -- Scroll by relative steps or reset if invoked without argument. Type \u0026#34;help dashboard assembly\u0026#34; followed by dashboard assembly subcommand name for full documentation. Type \u0026#34;apropos word\u0026#34; to search for commands related to \u0026#34;word\u0026#34;. Type \u0026#34;apropos -v word\u0026#34; for full documentation of commands related to \u0026#34;word\u0026#34;. Command name abbreviations are allowed if unambiguous. 以此类推。\n多终端输出 为了解决上面所说的输入部分过少的问题，可以使用多个终端。dashboard -ouput \u0026lt;terminal\u0026gt;中，可以手动指定终端来显示信息。\n首先创建多个终端，例如这里我使用 Tabby 自带的分割终端功能：\n然后在其中一个终端运行tty，得到编号：\n然后在另一个终端运行 dashboard -output /dev/pts/13，这当中 /dev/pts/13 需要修改为你运行 tty 获得的具体输出。\n这样右边终端就有了我们需要的信息。你可能觉得左边还有这些信息不够美观，很简单，按下 Ctrl + L 就可以清空当前内容，只保留接下来的行：\n我的自定义配置 为了持久化保存配置，参考官方的指南3，可以在多处中任意一处创建配置文件。我这里选择 ~/.config/gdb-dashboard/init 位置。可以首先进入 ~/.config 文件夹，创建 gdb-dashboard 文件夹，然后在其中创建 init 文件如下：\n1 2 3 4 dashboard -layout assembly breakpoints expressions history memory registers !source stack !threads variables dashboard assembly -style height 20 dashboard assembly -style highlight-line True dashboard -output /dev/pts/2 其中第一行隐藏了 source 以及 threads，因为目前的实验中用不到。之后第二行到第三行设置了 assembly 的风格。最后一行设置了输出的另一个终端。美中不足是每次新打开双终端使用 GDB Dashboard，都需要根据 tty 输出来修改 .gdbinit。\n展望 我也搜到有 pwndbg 4之类的调试器，看起来更强大。\n两天后，我写了相应博客，参考 pwndbg 教程与自定义配置 。\n参考资料 神仙GDB调试工具 gdb-dashboard. 知乎. https://zhuanlan.zhihu.com/p/435918702\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nGDB dashboard. Github. https://github.com/cyrus-and/gdb-dashboard\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUse personal configuration files. https://github.com/cyrus-and/gdb-dashboard/wiki/Use-personal-configuration-files\u0026#160;\u0026#x21a9;\u0026#xfe0e;\npwndbg. Github. https://github.com/pwndbg/pwndbg\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-10-20T00:00:00Z","image":"https://ovideros.site/p/gdb_dashboard/tabby2_hu_a4c880f9abf12978.png","permalink":"https://ovideros.site/p/gdb_dashboard/","title":"GDB Dashboard 教程"},{"content":"此前也有不少介绍 CSAPP Datalab 的内容123。本文旨在记录我在课程中遇到的 CSAPP Datalab，提供一些个人的解题思路。本文中许多解法并非最优，只是代表了个人的思路。本文并非科普性质，更多是为了未来的自己所写。\nAI创作声明：本文全文手敲。Datalab 实验绝大部分未使用AI，但在howManyBits、intLog2函数上，询问过AI获取思路。\n前置知识 C 语言基础，了解位运算。掌握 CSAPP 第二章内容，包括无符号数、有符号数的转换、运算，浮点数的IEEE标准与运算。\n环境搭建 本文并不会仔细写如何搭建环境，建议有问题多问AI。\n建议在x86_64架构4的Linux环境下完成该Lab。因为我的笔记本是Mac，所以利用VSCode SSH连接远程ubuntu服务器完成。也可以选择使用希冀网站上的桌面，或者在Windows系统下使用WSL等方法。\n函数分析 bitXor函数 函数要求：\n函数名 bitXor 参数 int x, int y 功能实现 x^y 要求 只能使用 ~ 和 实现分析：\n由于 a^b = (a \u0026amp; ~b) | (~a \u0026amp; b)， 又因为 c | d = ~(~c \u0026amp; ~d)， 带入得到 a^b = ((a \u0026amp; ~b) \u0026amp; ~(~a \u0026amp; b))\n函数实现：\n1 2 3 4 int bitXor(int x, int y) { // 代码实现 return ~(~(x \u0026amp; ~y) \u0026amp; ~(~x \u0026amp; y)); } getByte函数 函数要求：\n函数名 getByte 参数 int x, int n 功能实现 从字x中取出第n个字节，从右开始计数 要求 使用 ! ~ \u0026amp; ^ 分析：\n想要获取第 n 个字节，可以先让原先 x 右移 8n 个bit， 然后与0xFF进行\u0026amp;运算。为了获得8n，可以让n向左移位3位。\n函数实现：\n1 2 3 int getByte(int x, int n) { return (x \u0026gt;\u0026gt; (n \u0026lt;\u0026lt; 3)) \u0026amp; 0xFF; } logicalShift函数 函数要求：\n函数名 logicalShift 参数 int x, int n 功能实现 将x逻辑右移n位（左端补0） 要求 使用 ! ~ \u0026amp; ^ 分析：\nC语言的右移\u0026raquo;运算符默认是算术右移，也就是负数右移会高位补0 。 可以进行分类，如果x为正数，直接返回x右移；如果x为负数，则右移后将高位变成0 。但是如果要实现分类，就刚好是后面的实现三元运算符。更简单的就是直接将高位变成0，无论x正负，这样更简便。\n错误思路： 这说明需要构造 00\u0026hellip;011\u0026hellip;1这样的mask。为了利用C语言自带的右移，我们可以首先构造 011\u0026hellip;1，然后右移 n-1 位即可。实际上无法使用减法-，于是只能先右移 n 位，然后左移 1 位。取反，得到 100\u0026hellip;0，就只需要将 1 左移 31 位。\n然而在右移 n 位再左移 1 位时，低位会变成 0，错误。\n更改：为了构造 00\u0026hellip;011\u0026hellip;1 这样的mask，取反，就是要构造 11\u0026hellip;100\u0026hellip;0，于是在 100\u0026hellip;0 基础上右移 n 位，然后左移 1 位。\n函数实现：\n1 2 3 4 int logicalShift(int x, int n) { int mask = ((1 \u0026lt;\u0026lt; 31) \u0026gt;\u0026gt; n) \u0026lt;\u0026lt; 1; return ~mask \u0026amp; (x \u0026gt;\u0026gt; n); } bitCount函数 函数要求：\n函数名 bitCount 参数 int x 功能实现 返回该字中二进制 1 的个数 要求 使用 ! ~ \u0026amp; ^ 分析：\nPPT 与课上讲过，参考即可：\n将32位中每四位分组，首先利用位运算统计每个四位中1的个数（利用移位、掩码与加法）。 然后，将得到的32位的前16位与后16位相加。现在变成了4组4位的值，每个都累计了1的数量。 再按照第一步方法，进行累计将第一组加到第二组，第三组加到第四组，真正有效的变成了 0-3 位以及 8-11 位。 移位，将这两个有效的组加起来，最后与 0x3F (0b111111) 进行按位与运算，得到结果。之所以是 0x3F，因为 32 位最大就是有 32 个 1，最高会到 0b100000 。当然前面两个高位也是 0，实际上改成 0xFF也行。 最后实现的时候注意该C版本不支持后面定义，必须前面声明完所有变量。\n函数实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 int bitCount(int x) { int mask0 = 0x11 | (0x11 \u0026lt;\u0026lt; 8); int mask1 = mask0 | (mask0 \u0026lt;\u0026lt; 16); int mask2; // old C standard, must declare it first. int sum = x \u0026amp; mask1; sum = sum + (x \u0026gt;\u0026gt; 1 \u0026amp; mask1); sum = sum + (x \u0026gt;\u0026gt; 2 \u0026amp; mask1); sum = sum + (x \u0026gt;\u0026gt; 3 \u0026amp; mask1); sum = sum + (sum \u0026gt;\u0026gt; 16); mask2 = 0xF | (0xF \u0026lt;\u0026lt; 8); sum = (sum \u0026amp; mask2) + ((sum \u0026gt;\u0026gt; 4) \u0026amp; mask2); return (sum + (sum \u0026gt;\u0026gt; 8)) \u0026amp; 0x3F; } conditional函数 函数要求：\n函数名 conditional 参数 int x, int y, int z 功能实现 int x, int y, int z 要求 使用 ! ~ \u0026amp; ^ 分析：\n我们可以使用的操作符中，唯一与逻辑相关的就是非 ! 操作符。 所以，需要利用该符号来判断 x 是否为 0 。\n错误想法： 仅当 x 为 0 时，!x 为 1，此时将 1 左移 31 位，就能得到全1的mask，与 z 进行按位与运算。同理，仅当 x 不为 0 时，!!x 为 1，此时左移 31 位，与 y 进行按位与运算。最后将两个结果用或连接即可。\n错误理解了左移运算，还是右边补0，达不到想要的效果。 在左移 31 位后，再右移 31 位，这样根据算术右移，便能得到全1的mask。\n函数实现：\n1 2 3 int conditional(int x, int y, int z) { return ((!!x \u0026lt;\u0026lt; 31 \u0026gt;\u0026gt; 31) \u0026amp; y) | ((!x \u0026lt;\u0026lt; 31 \u0026gt;\u0026gt; 31) \u0026amp; z); } tmin函数 函数要求：\n函数名 tmin 参数 void 功能实现 返回最小的补码 要求 使用 ! ~ \u0026amp; ^ 分析：\n在 32 位下，最小补码就是 100..0，将 1 左移 31 位即可。\n函数实现：\n1 2 3 int tmin(void) { return 1 \u0026lt;\u0026lt; 31; } fitsBits函数 函数要求：\n函数名 fitsBits 参数 int x, int n 功能实现 x的补码是否可以表示成n位 要求 使用 ! ~ \u0026amp; ^ 分析：\n对于正数与负数分类讨论。\n在正数情况下，若能表示为 n 位补码，则其第 n 位必然为 0（否则补码为负数）， 并且更高位也都为 0 。 可以将 x \u0026raquo; (n - 1) ，此时如果所有位都为 0，则说明满足条件。 可以使用异或运算^，然后取反，则满足条件时，返回1，否则返回0 。\n在负数情况下，若能表示为 n 位补码，则其第 n 位必然为 1（否则补码为正数）， 并且更高位也都为 1 。 可以将 x \u0026raquo; (n - 1) ，此时如果所有位都为 1，则说明满足条件。 可以使用异或运算^，然后取反，则满足条件时，返回1，否则返回0 。\n可以看到，上面两者讨论有许多地方都可以简化。设 num 为 x \u0026raquo; (n - 1)， 则表达式为 !(num ^ 0) | !(num ^ ~0) 。\n函数实现：\n1 2 3 4 5 int fitsBits(int x, int n) { int n_1 = n + ~1 + 1; int num = x \u0026gt;\u0026gt; n_1; return !(num ^ 0) | !(num ^ ~0); } dividePower2函数 函数要求：\n函数名 dividePower2 参数 int x, int n 功能实现 计算 x/(2^n)，其中 0 \u0026lt;= n \u0026lt;= 30 要求 向0取整。使用 ! ~ \u0026amp; ^ 分析：\n对于正数，只需要向右移位 n 即可。\n对于负数，计算 (x + (1 \u0026laquo; k) - 1) \u0026raquo; k，其中 k 为移位次数。 注意其中无法使用 - 1，换成 + (~1 + 1)。\n函数实现：\n1 2 3 4 int dividePower2(int x, int n) { int mask = x \u0026gt;\u0026gt; 31; return (~mask \u0026amp; (x \u0026gt;\u0026gt; n)) | (mask \u0026amp; ((x + (1 \u0026lt;\u0026lt; n) + (~1 + 1)) \u0026gt;\u0026gt; n)); } negate函数 函数要求：\n函数名 negate 参数 int x 功能实现 返回 -x 要求 使用 ! ~ \u0026amp; ^ 分析：\n负数等于取反加一。\n函数实现：\n1 2 3 int negate(int x) { return ~x + 1; } howManyBits函数 函数要求：\n函数名 howManyBits 参数 int x 功能实现 返回表示 x 的补码所需的最少位数 要求 使用 ! ~ \u0026amp; ^ 分析：\n首先，分析正数与负数。我们可以发现，正数需要找到最高位的1，然后将结果加1 。负数需要找到最高位的0，然后将结果加1 。这两者统一起来很简单——只需要对负数按位取反，就可以使用正数的逻辑。\n接着，参考下方的intLog2函数，使用分治的思想，找到最高位。\n在intLog2的count基础上加2，因为二进制1需要至少两位来表示，但是 intLog2(1) 的值为0 。\n但是，这样对于二进制0来说，其intLog2不存在，而最少表示数为1 。因此加上特殊逻辑\n函数实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int howManyBits(int x) { int upper16, upper8, upper4, upper2, upper1; int mask16 = 1 \u0026lt;\u0026lt; 31 \u0026gt;\u0026gt; 15; int mask8 = 0xff \u0026lt;\u0026lt; 8; int mask4 = 0xf0; int mask2 = 0xc; int mask1 = 2; int count = 0; int is_negative = ((x \u0026gt;\u0026gt; 31) \u0026amp; 1) \u0026lt;\u0026lt; 31 \u0026gt;\u0026gt; 31; x = (is_negative \u0026amp; ~x) | (~is_negative \u0026amp; x); upper16 = !(mask16 \u0026amp; x) \u0026lt;\u0026lt; 31 \u0026gt;\u0026gt; 31; count = (~upper16 \u0026amp; 16) | (upper16 \u0026amp; 0); x = (~upper16 \u0026amp; (x \u0026gt;\u0026gt; 16)) | (upper16 \u0026amp; x); upper8 = !(mask8 \u0026amp; x) \u0026lt;\u0026lt; 31 \u0026gt;\u0026gt; 31; count = (~upper8 \u0026amp; (count + 8)) | (upper8 \u0026amp; count); x = (~upper8 \u0026amp; (x \u0026gt;\u0026gt; 8)) | (upper8 \u0026amp; x); upper4 = !(mask4 \u0026amp; x) \u0026lt;\u0026lt; 31 \u0026gt;\u0026gt; 31; count = (~upper4 \u0026amp; (count + 4)) | (upper4 \u0026amp; count); x = (~upper4 \u0026amp; (x \u0026gt;\u0026gt; 4)) | (upper4 \u0026amp; x); upper2 = !(mask2 \u0026amp; x) \u0026lt;\u0026lt; 31 \u0026gt;\u0026gt; 31; count = (~upper2 \u0026amp; (count + 2)) | (upper2 \u0026amp; count); x = (~upper2 \u0026amp; (x \u0026gt;\u0026gt; 2)) | (upper2 \u0026amp; x); upper1 = !(mask1 \u0026amp; x) \u0026lt;\u0026lt; 31 \u0026gt;\u0026gt; 31; count = (~upper1 \u0026amp; (count + 1)) | (upper1 \u0026amp; count); x = (~upper1 \u0026amp; (x \u0026gt;\u0026gt; 1)) | (upper1 \u0026amp; x); x = x \u0026lt;\u0026lt; 31 \u0026gt;\u0026gt; 31; return (~x \u0026amp; 1) | (x \u0026amp; (count + 2)); } isLessOrEqual函数 函数要求：\n函数名 isLessOrEqual 参数 int x, int y 功能实现 如果 x \u0026lt;= y，返回1；否则返回0 要求 使用 ! ~ \u0026amp; ^ 分析：\n最简单的想法，就是让 y - x ，然后判断最高位的位数是否为1 。 如果是，则返回0；如果不是，则返回 1 。\n因为不支持减法，所以写为 y + ~x + 1。然而，实际会遇到溢出问题， 包括正溢出与负溢出。\n因为当x与y符号相同时，不会发生溢出现象，所以使用排除法—— 当x为负且y为正时(signx \u0026amp; !signy)，此时一定满足，返回1，使用按位或运算与原等式连接； 当x为正且y为负时(signy \u0026amp; !signx)，此时一定不满足，返回0 。该逻辑操作可以将条件取反，然后与之前的式子进行按位与运算。这样当条件成立时，一定返回0，达到目的。\n函数实现：\n1 2 3 4 5 6 int isLessOrEqual(int x, int y) { int sub = y + ~x + 1; int signx = x \u0026gt;\u0026gt; 31; int signy = y \u0026gt;\u0026gt; 31; return (!(signy \u0026amp; !signx)) \u0026amp; ((signx \u0026amp; !signy) | !((sub \u0026gt;\u0026gt; 31) \u0026amp; 1)); } intLog2函数 函数要求：\n函数名 intLog2 参数 int x 功能实现 返回 floor(log2 x)，其中 x \u0026gt; 0 要求 使用 ! ~ \u0026amp; ^ 分析：\n要返回x的log2的值，就相当于要找到x的最高位1的位置。 例如，16的二进制为10000，就返回4；1的二进制为1，返回0 。 这说明返回值就是最高位1的值减一。\n从最基本的角度来说，可以使用线性的方法，一次次看第n位是否为1，然后返回最大的。然而，这样显然相当低效，需要进行32次操作。\n于是，考虑使用分治。首先判断高16位是否存在1。如果高位没有，则说明只考虑低16位的值；如果高位有1，则可以将高16位移位，并且结果加上16 。这些判断可以使用 conditional 函数的逻辑。例如 (~upper16 \u0026amp; 16) | (upper16 \u0026amp; 0) ，在 upper16 为全1时返回0，全0时返回16 。\n继续分治，按照相同逻辑进行运算，从 32 -\u0026gt; 16 -\u0026gt; 8 -\u0026gt; 4 -\u0026gt; 2 -\u0026gt; 1。\n函数实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int intLog2(int x) { int upper16, upper8, upper4, upper2, upper1; int mask16 = 1 \u0026lt;\u0026lt; 31 \u0026gt;\u0026gt; 15; int mask8 = 0xff \u0026lt;\u0026lt; 8; int mask4 = 0xf0; int mask2 = 0xc; int mask1 = 2; int count = 0; upper16 = !(mask16 \u0026amp; x) \u0026lt;\u0026lt; 31 \u0026gt;\u0026gt; 31; count = (~upper16 \u0026amp; 16) | (upper16 \u0026amp; 0); x = (~upper16 \u0026amp; (x \u0026gt;\u0026gt; 16)) | (upper16 \u0026amp; x); upper8 = !(mask8 \u0026amp; x) \u0026lt;\u0026lt; 31 \u0026gt;\u0026gt; 31; count = (~upper8 \u0026amp; (count + 8)) | (upper8 \u0026amp; count); x = (~upper8 \u0026amp; (x \u0026gt;\u0026gt; 8)) | (upper8 \u0026amp; x); upper4 = !(mask4 \u0026amp; x) \u0026lt;\u0026lt; 31 \u0026gt;\u0026gt; 31; count = (~upper4 \u0026amp; (count + 4)) | (upper4 \u0026amp; count); x = (~upper4 \u0026amp; (x \u0026gt;\u0026gt; 4)) | (upper4 \u0026amp; x); upper2 = !(mask2 \u0026amp; x) \u0026lt;\u0026lt; 31 \u0026gt;\u0026gt; 31; count = (~upper2 \u0026amp; (count + 2)) | (upper2 \u0026amp; count); x = (~upper2 \u0026amp; (x \u0026gt;\u0026gt; 2)) | (upper2 \u0026amp; x); upper1 = !(mask1 \u0026amp; x) \u0026lt;\u0026lt; 31 \u0026gt;\u0026gt; 31; count = (~upper1 \u0026amp; (count + 1)) | (upper1 \u0026amp; count); return count; } floatAbsVal函数 函数要求：\n函数名 floatAbsVal 参数 unsigned uf 功能实现 返回 uf 的绝对值，unsigned 理解为 float 要求 当参数为NaN时，直接返回参数 分析：\n当 uf 不是 NaN 的时候，只需要将最高位改成0即可，很简单： ~(1 \u0026laquo; 31) \u0026amp; uf 。\n重点是判断 uf 是否为 NaN。NaN的8位exp都为1，且23位frac不全为0 。 前者条件可以表述为 (uf \u0026laquo; 1 \u0026raquo; 24) == 0xff ，也就是将原数的exp去除，为 0xff； 后者条件表述为 (uf \u0026laquo; 9) != 0 ，也就是frac位不全为 0。\n函数实现：\n1 2 3 4 5 unsigned floatAbsVal(unsigned uf) { if (((uf \u0026lt;\u0026lt; 1 \u0026gt;\u0026gt; 24) == 0xff) \u0026amp; ((uf \u0026lt;\u0026lt; 9) != 0)) return uf; return ~(1 \u0026lt;\u0026lt; 31) \u0026amp; uf; } ###s floatScale1d2函数\n函数要求：\n函数名 floatScale1d2 参数 unsigned uf 功能实现 返回 0.5*f 要求 当参数为NaN时，直接返回参数；可以使用任何操作符，以及流程 分析：\n当参数为 NaN 时，直接仿照上面函数的逻辑判断，并返回输入。 对于exp为全1的情况，说明此时代表无穷大，除以二仍然不变，因此可以并入相同逻辑。\n除以2不会改变符号，所以符号位应该不变。\n如果除以2之前与之后，exp都处在规格化之内，那么只用将exp减去1即可。 这对应了 exp \u0026gt;= 0x02 的情况。\n当 exp == 0x01 时，说明此时浮点数从规格化值变为非规格化值，将小数部分最高位之外增加1位1，对这个整体进行偶数舍入除以2，变成新的小数部分。\n当 exp == 0x00 时，此时在非规格的情况下操作，取小数部分按偶数舍入除以2。\n函数实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 unsigned floatScale1d2(unsigned uf) { unsigned sign = (uf \u0026gt;\u0026gt; 31) \u0026amp; 1; unsigned exp = uf \u0026lt;\u0026lt; 1 \u0026gt;\u0026gt; 24; unsigned frac = uf \u0026amp; 0x7fffff; unsigned round, guard; if (exp == 0xff) return uf; if (exp \u0026gt;= 0x02) { exp -= 1; } else { if (exp == 0x01) { exp = 0; frac = (1 \u0026lt;\u0026lt; 23) | frac; } round = frac \u0026amp; 1; frac = frac \u0026gt;\u0026gt; 1; if (round == 1) { guard = frac \u0026amp; 1; if (guard == 1) { frac += 1; } } } return (sign \u0026lt;\u0026lt; 31) | (exp \u0026lt;\u0026lt; 23) | frac; } floatFloat2Int函数 函数要求：\n函数名 floatFloat2Int 参数 unsigned uf 功能实现 返回 (int) uf 的位级表示 要求 当输入超出 int 表示范围时（包括NaN与inf），返回 0x80000000u 分析：\n仿照刚才逻辑，若exp位为全1，直接返回 0x80000000u。\n计算指数位代表的2的指数大小，利用 e = exp - bias。如果 e 小于 0，则直接返回0；若 e 大于等于 31，说明超出 int 表示范围，返回 0x80000000u 。\n接下来需要对小数位进行移位操作。一次2的乘法，就相当于1次移位。\n在小数位最高位多增加一位1，然后根据 e 与 23 的大小关系，选择向左或者向右移位，得到结果。\n最后，根据符号正负，正数直接返回，负数需要返回补码（取反加一）。\n函数实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int floatFloat2Int(unsigned uf) { unsigned sign = (uf \u0026gt;\u0026gt; 31) \u0026amp; 1; unsigned exp = uf \u0026lt;\u0026lt; 1 \u0026gt;\u0026gt; 24; unsigned frac = uf \u0026amp; 0x7fffff; unsigned bias = 127; unsigned result; int e = exp - bias; int index = 23 - e; if (exp == 0xff) return 0x80000000u; if (e \u0026lt; 0) return 0; if (e \u0026gt;= 31) return 0x80000000u; if (index \u0026gt;= 0) { result = ((1 \u0026lt;\u0026lt; 23) | frac) \u0026gt;\u0026gt; index; } else { result = ((1 \u0026lt;\u0026lt; 23) | frac) \u0026lt;\u0026lt; (-index); } if (!sign) { return result; } else { return ~result + 1; } } 实验总结 该实验通过位运算的角度，加强了对于int底层表示、float表示的理解。\n对于难度为4的题目，确实需要较多的思考。bitCount在课上讲过，所以可以写出来。 不过 howManyBits 与 intLog2 之前没有见过。一开始感觉根本没有思路，因为无法进行32次每一位的操作。后面询问AI（仅做辅导提示作用，没有直接给出答案），提示我利用分治的方法思考，我便找到了解法。确实相当巧妙。\n还有许多细节上的问题。例如，!运算是这当中应该积极使用的操作符，可以将所有非0的值映射为0，只有0还是1 。结合上移位操作，便可以当做条件判断使用。这在许多地方都有应用。\n以及对于mask，可以手动构造，截取指定的位，进行分析。这在浮点数操作中有应用。\n对于减法减去x，可以使用 + ~x +1 实现。当x是一个较小的常数时，此方法都有用。但是特别注意，如果 x 本身接近 Tmin 或者 Tmax，会造成加法或者说减法的正溢与负溢，这在isLessOrEqual函数中有所体现。\n浮点数中，floatScale1d2要注意舍入到偶数的逻辑——利用舍入后的最低位guard，进行分类判断。floatFloat2Int中，判断移位的正负，进而对小数位进行移位，得到转换后的正数。为了实现这个函数，我也在C语言中自己尝试了float到int的强制类型转换，其舍入逻辑就是简单的截断小数位，或者说向0舍入。\n参考资料 更适合北大宝宝体质的 Data Lab 踩坑记. https://arthals.ink/blog/data-lab\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCSAPP 之 DataLab详解，没有比这更详细的了. 知乎. https://zhuanlan.zhihu.com/p/59534845\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n实验 1：Data Lab. CSAPP 电子书. https://hansimov.gitbook.io/csapp/labs/data-lab\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nx86-64. Wikipedia. https://en.wikipedia.org/wiki/X86-64\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-10-19T00:00:00Z","permalink":"https://ovideros.site/p/csapp_datalab/","title":"📊 CSAPP Datalab 实验指南"},{"content":"本文探讨了如何使用x11+XQuartz客户端，在Mac上连接远程Ubuntu（或其他Linux）服务器，并弹出应用窗口。\n然而，实际上这种效果并不是最优的，例如最简单的xeyes或者glxgears都不是很流畅。更好的方案包括VNC，或者使用更直接的远程桌面程序（如ToDesk、向日葵等等）。\n之前我也尝试过VNC，以及ToDesk等程序。未来有机会可以梳理。\n预备知识 假设你了解基本的 Linux 环境，以及命令行操作。可以参考 Missing Semester 进行学习。\nUbuntu服务器端操作 修改 /etc/ssh/sshd_config 中关于 SSH 的配置，将\n1 #X11Forwarding yes 或者\n1 X11Forwarding no 选项，修改为：\n1 X11Forwarding yes 可以使用任意编辑器（如 Vim1, Nano2）编辑后保存，需要 sudo 权限（sudo vim /etc/ssh/sshd_config）。\n然后，重启 SSH 服务：\n1 sudo systemctl restart sshd 之后，安装 X11 相关的包（假设使用 Ubuntu，其他发行版可使用其他包管理器）：\n1 2 sudo apt update sudo apt install -y xauth x11-apps Mac客户端操作 下载 XQuartz。吐槽一下，好久没有更新了。\n因为我配置了本地的 zsh，使用了带有 UTF-8 的主题，所以 XQuartz 打开后显示乱码。（理论上好像也有配置 XQuartz 使用 UTF-8 的方法，但是懒得做了）\n有一些更先进的终端软件，支持 UTF-8 编码，如 Tabby。该终端支持各个平台，也比较现代化与美观，且支持 X11 转发，符合需求。进入 Github 发布页面，下载对应版本即可（m芯片的 Mac 下载 macos-arm64.dmg 后缀的包，然后正常安装）。\n新建窗口，进入本机的 Shell。然后使用 ssh -Y user@host 连接远程服务器，其中 user@host 是目标服务器的用户名与ip。更多有关 SSH 登录的细节参考 Missing Semester 的第五讲34。\n登录后，运行 echo $DISPLAY，输出应该如下：\n1 localhost:10.0 也可以是 11.0 等数字。\n尝试运行 xeyes，应该能在本地 Mac 运行 XQuartz，弹出一个窗口，显示效果如下：\n这说明基本的 X11 流程配置完成。\n如果配置中遇到问题，建议带着具体报错询问 AI。\nGLX/OpenGL设置 上述实现了基本 X11 功能，但对于依赖 GLX/OpenGL 的包（例如 Pygame 等），则还需要进一步配置。\n首先确保Ubuntu服务器端安装相应包：\n1 sudo apt install libgl1-mesa-glx libgl1-mesa-dri mesa-utils 然后在Mac上打开终端，退出XQuartz，运行下面指令，把 XQuartz 的间接 GLX 打开：\n1 2 defaults write org.macosforge.xquartz.X11 enable_iglx -bool true defaults write org.xquartz.X11 enable_iglx -bool true 重新启动XQuartz，⌘+,打开设置，确保开启允许网络客户端连接，如图：\n重新连接服务器（ssh -Y user@host），尝试运行 glxinfo，确保没有报错。如果有关于swrast的报错\n1 2 libGL error: No matching fbConfigs or visuals found libGL error: failed to load driver: swrast 可以尝试设置环境变量：\n1 export LIBGL_ALWAYS_INDIRECT=1 之后运行glxgears测试：\n1 glxgears 可以看到本地弹出窗口，显示旋转的齿轮。说明配置成功。\n总结 然而，由于X11本身协议并没有那么好，所以很可能看起来卡顿。为了更流畅的体验，可能还是要使用其他方案。X11本身方便在不创建完整的桌面，只是弹出部分程序的窗口。\n如果你有更好的远程桌面相关方案，也欢迎讨论！（如VNC、商业软件等等）\n参考资料 Vim. Wikipedia. https://en.wikipedia.org/wiki/Vim_(text_editor)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nGNU Nano. Wikipedia. https://en.wikipedia.org/wiki/GNU_nano\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n命令行环境. Missing Semester 中文版. https://missing-semester-cn.github.io/2020/command-line/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n[自制双语字幕] 计算机教育缺失的一课(2020) - 第5讲 - 命令行环境 . https://www.bilibili.com/video/BV1Jh4y1Z7SV/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-10-18T00:00:00Z","permalink":"https://ovideros.site/p/x11_mac/","title":"如何在Mac上连接远程服务器，并显示应用窗口？"},{"content":" 该内容于2025年8月18日——2025年9月2日每日连载，共16天，整理如下。于2025年10月13日上传博客。\n油管上有许多精良的视频博主，有些在 b 站有官方搬运，有些则是被零散搬运。\n该推荐旨在精选一些 CS、数学相关的博主，进行推荐，并简要介绍。\n由于我的关注量有限，只能支撑我推荐两三周的量（）后续如何，后续再看。\n第一周 1 ✨每日油管博主推荐第一期✨——3Blue1Brown，简称 3b1b，创始人为 Grant Sanderson，毕业于 Stanford。1\n作为最知名的数学博主（可能没有之一），他为制作动画创建的 manim 库，被广泛使用。他的视频风格也成了优质视频的标杆。\n大概在初高中时期，我就在 b 站看过不少他的视频）虽然大多数都一知半解，浮光掠影。不过，确实从可视化中，感受到了数学的优美。\n上了大学，我也看了著名的微积分与线性代数系列。以及关于深度学习、量子计算的系列，都很有意思。\n目前，该频道也有十多年了，视频质量却一直很高。但愿以后也能延续下去）\n2 ✨每日油管博主推荐第二期✨——Veritasium，中文名真理元素，有 b 站官方频道。该名字是一种原子序数为 i，原子量 42 的虚构化学元素。创始人Derek Muller 拥有教育物理的 PhD，专业性较高2。该频道涉及广泛的科学与工程领域，包括但不限于数学、物理、化学、生物、材料、机械、建筑、经济等等。然而，每期视频都能做到深入浅出。\n对于数学物理视频，他会制作生动的可视化，以及一些数学家、物理学家的动画；对于工程领域，他会选择实地走访，或者采访在世的学者等。其形式的多样，在大众接受度与专业度上，达到了精巧的平衡。个人认为是科普视频的典范。\n3 ✨每日油管博主推荐第三期✨——AI Warehouse。今天推荐一个轻松的。该频道的主角是 Albert 与 Kai，两个具有视觉感知的方块 AI。频道会设置一些任务，以及 reward，通过强化学习来训练 AI（评论中说是 PPO），完成任务。\n有些视频还会涉及到 Multi-agent RL，看着 Albert 与 Kai ，很可爱，很有意思 ()。\n4 ✨每日油管博主推荐第四期✨——BranchEducation。该频道利用 3D 动画来解释各类事务，例如 CPU、GPU、RAM、CG 等等的工作原理。视频相当深入浅出，善用例子，能够生动形象地讲解工程的本质。\n该频道相当偏 \u0026ldquo;engineering\u0026rdquo;，可以体会到，工程很多时候就是把东西搭好，与“纯粹的科学”还是有区别的。不过，以我自己所看到的 AI 研究领域为例，许多 paper 其实也与工程差不太多了）\n5 ✨每日油管博主推荐第五期✨——Welch Labs。该频道对于 LLM 的科普，做到了顶级。例如，对于 Scaling Law、LLM可解释性、Deepseek MLA 等内容，都有可视化的深度讲解。\n该频道的展现方式也很有意思，做到了动画与手写的平衡。近期也与 3b1b 出了一期深度生成模型的 guest video，很有意思。\n6 ✨每日油管博主推荐第六期✨——ScienceClic。今天推荐一个物理频道。该频道通过可视化的手段，讲解了相对论、量子力学等“常见”的话题（这里常见指的是科普中常见）。\n其动画很美观，单纯从平面设计角度，也值得学习。如果有即将进入大二的同学，那么也不得不面对电磁学、相对论与量子力学。个人认为，拥有一些直观的印象，对学习总是有帮助的。\n7 ✨每日油管博主推荐第七期✨——Mathemaniac。今天推荐一个数学频道。起因是我暑假看机器人学的时候，想要了解一些旋转方面的群论知识，便搜了搜，发现该频道有对于李群、李代数的讲解，大概能加深对于 SO(3)、SE(3) 等的理解。\n不过，说来也惭愧，我还只看了前面几期（）后面找时间再看看。\n第二周 8 ✨每日油管博主推荐第八期✨——Emergent Garden。今天推荐一个 AI 向频道。该频道有些 MC 方向内容，也会涉及到一些“潮流”的概念，如 Vibe Coding、AI Agents 等等。\n不得不说，Vibe Coding 确实爽，有一种当产品经理，指挥 AI 打工的感觉。然而，当前模型往往又没有那么智能，所以埋下的雷，都需要你自己来拆。就算让 AI debug，个人的活还是不轻松，往往要理解系统，并对 AI 的内容做出引导。感觉这也不算真正的 Vibe Coding，只能有一半吧。\n9 ✨每日油管博主推荐第九期✨——SteveMould，有 b 站官方频道。该频道讲究现实中趣味的物理科普，包括一些奇特的材料、物理现象等。\n该频道普及了许多那些看起来反直觉，但实际上深度思考后合理的现象。往往这些现象都蕴含着我们平时看不到的点，拓展自己的知识边界。\n10 ✨每日油管博主推荐第十期✨——Core Dumped。今天来推荐一个我近期常看的计算机频道。该频道由南美 CS 工程师创建，因为自身口音，选择使用 AI 配音；但内容相当真诚，用动画来展现计算机的核心概念。讲解也相当清晰。\n该频道讲解的是计算机系统方面，从最底层的电路（数字逻辑），到组成 CPU 与内存（计算机组成原理），如何分配内存与任务调度（操作系统），涉及到编译等操作，可谓是相当全面。\n让我吃惊的是，他的视频居然是用 PPT 动画制作的。看来，好的内容往往都是内核充盈，不依赖于具体工具吧）。\n11 ✨每日油管博主推荐第十一期✨——Artem Kirsanov。该频道是深度学习相关，也有许多其他有意思的内容。例如，该频道介绍了反向传播、Hopfield 网络与玻尔兹曼机，这些都是现代深度学习的基石；对于交叉熵与 VAE 的讲解，也都能让你体会到背后的直觉。\n该频道可视化做得相当不错。唯一的缺点可能是英语有点俄语口音，不过无伤大雅）\n12 ✨每日油管博主推荐第十二期✨——CodeAesthetic。该频道是软件工程相关，b 站上也有翻译（代码美学）。\n该频道会介绍一些经典内容——例如变量命名、OOP 思想、不要过早优化、减少嵌套；也会介绍一些“暴论”——例如**“不写注释”**。\n可惜该频道更新比较缓慢，上次更新也是 23 年了）但愿之后能再次看到吧。\n13 ✨每日油管博主推荐第十三期✨——Deepia。这是一个深度学习相关博主，利用 manim 制作视频，设计了一些经典话题，例如 Autoencoder、VAE、Diffusion 等深度生成模型，PCA、t-SNE、UMAP 等降维方法。\n其视频讲解相当清楚，推荐。\n14 ✨每日油管博主推荐第十四期✨——2swap。这是一个兴趣广泛的博主，自己的频道接受是 \u0026ldquo;I make videos about emergent systems in mathematics!\u0026rdquo;。所以，什么是数学里的“涌现系统”呢？\n该频道最初几个视频是关于 connect4 3的，我之前没听说过。查了一查，可以简单理解为带有重力版本的“四”子棋，也就是横竖斜着连成 4 子。这几个视频都挺有意思。\nGRAVITY BASINS 讲述了一个质点在固定的多个星球中，哪些区域会被吸引到哪一个星球。这些动画展现了多体问题的复杂性。\n曼德勃罗集4是数学科普的常见题材，也是最知名的分形之一。该视频对于曼德勃罗集的可视化相当全面。许多频道也都做过曼德勃罗集：\n真理元素——这个方程会改变你的世界观 3blue1brown——【官方双语】芒德布罗特集是如何从牛顿的工作中产生的 妈咪说——【分形与混沌2】最有魅力的几何图形——曼德勃罗集与朱利亚集 天使与魔鬼共存 其后还有视频介绍 lambda 演算法，以及其他话题，我还正在看）其视频的选题，确实可以说是数学里的“涌现系统”——从基本与简洁的数学，组合与涌现出智能。\n第三周 15 ✨每日油管博主推荐第十五期✨——Nemean。这是一个计算机相关博主，其关于图论介绍的视频讲得很好，可视化与例子的把控都很合适。\n在曾经图论视频的三年之后，该频道才更新了第二期。从评论中可以得知这与疾病有关。许多时候，频道往往难以长久坚持，其一便是非全职 up 主，生活难免有变动；其二便是知识类 up 主，其制作视频所消耗的题材是线性的，然而自己知识增长却是对数的，因此往往会发现选题越来越难。\n在这两周的更新里，我虽然也就推荐了十几个博主，不过也涵盖了我目前了解的大部分——我也确实感觉想要推荐好的频道，越来越难。这也算是知识类 up 主的共性之一吧。\n16 ✨每日油管博主推荐第十六期✨——Freya Holmér。这是一个\u0026quot;tech art\u0026quot;相关博主。其关于贝塞尔曲线、线条函数的视频都具有很好的可视化。\n【Freya｜熟肉】贝塞尔曲线之美 【Freya｜熟肉】线条函数的连续性 去年，在复习数值分析时，在 b 站刷到了相关视频，看完感觉很有启发。如果你也是大二计科，那么也能从中感受到插值带来的艺术之美。\n然而，课本里插值就是一大堆冗杂的函数，你还需要背下来应付考试，只能让人感到恶心。看来，对于相同的知识，总能找到两种方式——一种是照本宣科的死记硬板，一种是可视化带来的直观理解吧。\n完结 伴随计院大三“第二周”小学期的结束，我也是时候完结油管博主推荐了。\n如果硬要推荐，也是可以继续水几周的，但这就违反了我做推荐的初衷——我并不是希望做一个完整的博主列表，而只是希望根据个人感想，推荐一些我认为真正有趣且独特的频道。在各位订阅这些频道之后，自然也会被推送到其他相近的频道。如果各位对其中某个频道达成了兴趣，那么我的目的就达到了。\n后续我也可能会推荐其他内容，敬请期待。\n3blue1brown. Wikipedia. https://en.wikipedia.org/wiki/3Blue1Brown\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDerek Muller. Wikipedia. https://en.wikipedia.org/wiki/Derek_Muller\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nConnect Four. Wikipedia. https://en.wikipedia.org/wiki/Connect_Four\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMandelbrot set. Wikipedia. https://en.wikipedia.org/wiki/Mandelbrot_set\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-10-13T00:00:00Z","permalink":"https://ovideros.site/p/youtuber_recommend/","title":"🎬每日油管博主推荐——合订本，共16话"},{"content":"脚注 本博客基于 Hugo 框架1，使用 hugo-theme-stack 主题2搭建。\n为了方便之后我在正文中进行引用，我希望“魔改”一下 footnote 脚注功能。原始的 footnote 只能显示数字，光标放上去可以跳转到文末处的链接，但是无法直接显示，这就导致你需要反复跳转，很麻烦。\n有些网站3便实现了方便的预览功能，只需要悬停，即可查看并复制脚注中的文本。\n在 AI 帮助下，此种行为自然很容易达成。\n首先，修改 assets/scss/custom.scss 文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 /* Tippy 内置 light-border 主题的细节微调，结合 Stack 的浅/深色方案。 */ .tippy-box[data-theme~=\u0026#39;light-border\u0026#39;] { color: var(--card-text-color-main); font-size: 1.4rem; line-height: 1.6; box-shadow: var(--shadow-l4); border-radius: var(--card-border-radius); } .tippy-box[data-theme~=\u0026#39;light-border\u0026#39;] .tippy-content { padding: 1rem 1.2rem; } .tippy-box[data-theme~=\u0026#39;light-border\u0026#39;] a { color: var(--accent-color); text-decoration: underline; } [data-scheme=\u0026#34;light\u0026#34;] .tippy-box[data-theme~=\u0026#39;light-border\u0026#39;] { background-color: #ffffff; border-color: rgba(0, 0, 0, 0.08); } [data-scheme=\u0026#34;light\u0026#34;] .tippy-box[data-theme~=\u0026#39;light-border\u0026#39;][data-placement^=\u0026#39;top\u0026#39;] \u0026gt; .tippy-arrow::before { border-top-color: #ffffff; } [data-scheme=\u0026#34;light\u0026#34;] .tippy-box[data-theme~=\u0026#39;light-border\u0026#39;][data-placement^=\u0026#39;bottom\u0026#39;] \u0026gt; .tippy-arrow::before { border-bottom-color: #ffffff; } [data-scheme=\u0026#34;light\u0026#34;] .tippy-box[data-theme~=\u0026#39;light-border\u0026#39;][data-placement^=\u0026#39;left\u0026#39;] \u0026gt; .tippy-arrow::before { border-left-color: #ffffff; } [data-scheme=\u0026#34;light\u0026#34;] .tippy-box[data-theme~=\u0026#39;light-border\u0026#39;][data-placement^=\u0026#39;right\u0026#39;] \u0026gt; .tippy-arrow::before { border-right-color: #ffffff; } [data-scheme=\u0026#34;dark\u0026#34;] .tippy-box[data-theme~=\u0026#39;light-border\u0026#39;] { background-color: rgba(54, 54, 54, 1); color: rgba(255, 255, 255, 0.92); border-color: rgba(255, 255, 255, 0.14); box-shadow: 0 20px 45px -25px rgba(0, 0, 0, 0.8); } [data-scheme=\u0026#34;dark\u0026#34;] .tippy-box[data-theme~=\u0026#39;light-border\u0026#39;][data-placement^=\u0026#39;top\u0026#39;] \u0026gt; .tippy-arrow::before { border-top-color: rgba(54, 54, 54, 1); } [data-scheme=\u0026#34;dark\u0026#34;] .tippy-box[data-theme~=\u0026#39;light-border\u0026#39;][data-placement^=\u0026#39;bottom\u0026#39;] \u0026gt; .tippy-arrow::before { border-bottom-color: rgba(54, 54, 54, 1); } [data-scheme=\u0026#34;dark\u0026#34;] .tippy-box[data-theme~=\u0026#39;light-border\u0026#39;][data-placement^=\u0026#39;left\u0026#39;] \u0026gt; .tippy-arrow::before { border-left-color: rgba(54, 54, 54, 1); } [data-scheme=\u0026#34;dark\u0026#34;] .tippy-box[data-theme~=\u0026#39;light-border\u0026#39;][data-placement^=\u0026#39;right\u0026#39;] \u0026gt; .tippy-arrow::before { border-right-color: rgba(54, 54, 54, 1); } 在 layouts/partials/head/custom.html 中加入相关的库：\n1 2 3 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/dist/tippy.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/dist/themes/light-border.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/animations/shift-away.css\u0026#34;\u0026gt; 在 layouts/partials/footer/custom.html 中实现逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js\u0026#34; defer\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/dist/tippy-bundle.umd.min.js\u0026#34; defer\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function () { if (typeof tippy === \u0026#39;undefined\u0026#39;) { return; } var noteRefs = document.querySelectorAll(\u0026#39;a.footnote-ref[role=\u0026#34;doc-noteref\u0026#34;]\u0026#39;); if (!noteRefs.length) { return; } var noteCache = new Map(); noteRefs.forEach(function (ref) { var targetId = ref.getAttribute(\u0026#39;href\u0026#39;); if (!targetId || targetId.charAt(0) !== \u0026#39;#\u0026#39;) { return; } targetId = targetId.slice(1); var note = document.getElementById(targetId); if (!note) { return; } if (!noteCache.has(targetId)) { var clone = note.cloneNode(true); clone.querySelectorAll(\u0026#39;.footnote-backref\u0026#39;).forEach(function (backref) { backref.remove(); }); noteCache.set(targetId, clone.innerHTML.trim()); } tippy(ref, { content: noteCache.get(targetId), allowHTML: true, interactive: true, theme: \u0026#39;light-border\u0026#39;, maxWidth: 360, appendTo: document.body, placement: \u0026#39;auto\u0026#39;, touch: [\u0026#39;hold\u0026#39;, 400], animation: \u0026#39;shift-away\u0026#39;, }); }); }); \u0026lt;/script\u0026gt; 这样就可以正确实现想要的功能了。\n公式 此外，原先的KaTeX最多只支持数学公式标号，但是没法做到交叉引用。如果未来要写一些更复杂的文章，这点有些麻烦。\n于是，询问AI有啥解决途径，回答到使用MathJax。查了查Hugo本身就支持KaTeX与MathJax4，并且我记得苏剑林的博客中用的也是MathJax5，遂让AI帮我写一写。\n写了后有问题，AI自己根据本地导出的html分析，解决了问题。最后需要修改两个文件。\n首先，还是那段 layouts/partials/article/components/math.html：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 {{/* 用 MathJax 替换 Hugo Stack 默认的 KaTeX，实现 \\label/\\ref 等高级特性。 */}} \u0026lt;script\u0026gt; window.MathJax = { tex: { inlineMath: [[\u0026#39;$\u0026#39;, \u0026#39;$\u0026#39;], [\u0026#39;\\\\(\u0026#39;, \u0026#39;\\\\)\u0026#39;]], displayMath: [[\u0026#39;$$\u0026#39;, \u0026#39;$$\u0026#39;], [\u0026#39;\\\\[\u0026#39;, \u0026#39;\\\\]\u0026#39;]], tags: \u0026#39;ams\u0026#39;, processEscapes: true, packages: {\u0026#39;[+]\u0026#39;: [\u0026#39;ams\u0026#39;]} }, options: { skipHtmlTags: [\u0026#39;script\u0026#39;, \u0026#39;noscript\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;textarea\u0026#39;, \u0026#39;annotation\u0026#39;, \u0026#39;annotation-xml\u0026#39;], ignoreHtmlClass: \u0026#39;gist|no-mathjax\u0026#39;, processHtmlClass: \u0026#39;main-article\u0026#39; }, loader: { load: [\u0026#39;[tex]/ams\u0026#39;] } }; \u0026lt;/script\u0026gt; \u0026lt;script async id=\u0026#34;MathJax-script\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 其次，主题自带的 smoothAnchors.ts 会给所有 href=\u0026quot;#…\u0026quot; 的链接挂平滑滚动逻辑，MathJax 重排时这些锚点会短暂无效，结果就报错。于是覆盖掉它：在 assets/ts/smoothAnchors.ts 新建同名文件，只在目标不是 #mjx-eqn-... 时才继续平滑滚动。MathJax 生成的引用链接就交给浏览器默认行为，既不会报错，也不会影响脚注、目录等其它锚点。\nassets/ts/smoothAnchors.ts 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 const anchorLinksQuery = \u0026#34;a[href]\u0026#34;; const mathJaxAnchorPrefix = \u0026#34;#mjx-eqn-\u0026#34;; const isMathJaxAnchor = (href: string): boolean =\u0026gt; { try { return decodeURI(href).startsWith(mathJaxAnchorPrefix); } catch { return href.startsWith(mathJaxAnchorPrefix); } }; function setupSmoothAnchors(): void { document.querySelectorAll\u0026lt;HTMLAnchorElement\u0026gt;(anchorLinksQuery).forEach((aElement) =\u0026gt; { const rawHref = aElement.getAttribute(\u0026#34;href\u0026#34;); if (!rawHref || !rawHref.startsWith(\u0026#34;#\u0026#34;)) { return; } if (isMathJaxAnchor(rawHref)) { return; } aElement.addEventListener(\u0026#34;click\u0026#34;, (event) =\u0026gt; { let decodedHref: string; try { decodedHref = decodeURI(rawHref); } catch { decodedHref = rawHref; } const targetId = decodedHref.substring(1); const target = document.getElementById(targetId); if (!target) { return; } event.preventDefault(); const offset = target.getBoundingClientRect().top - document.documentElement.getBoundingClientRect().top; window.history.pushState({}, \u0026#34;\u0026#34;, rawHref); scrollTo({ top: offset, behavior: \u0026#34;smooth\u0026#34;, }); }); }); } export { setupSmoothAnchors }; 相比于KaTeX，MathJax可以直接右键公式，复制Tex源码，这点挺方便的。\n同时，也支持交叉引用，例如我可以在此交叉引用下面的公式，见 \\eqref{eq:m} 。\n$$ \\begin{equation} \\begin{cases} \\nabla \\cdot \\mathbf{E} = \\frac{\\rho}{\\epsilon_0} \\\\ \\nabla \\cdot \\mathbf{B} = 0 \\\\ \\nabla \\times \\mathbf{E} = -\\frac{\\partial \\mathbf{B}}{\\partial t} \\\\ \\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{J} + \\mu_0 \\epsilon_0 \\frac{\\partial \\mathbf{E}}{\\partial t} \\end{cases} \\label{eq:m} \\end{equation} $$小结 折腾一番，总算让博客看起来更加美观，也更方便未来更新更多内容了（）\n参考文献 Hugo. https://gohugo.io/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHugo Theme Stack. https://github.com/CaiJimmy/hugo-theme-stack\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nYang Song. Generative Modeling by Estimating Gradients of the Data Distribution . https://yang-song.net/blog/2021/score/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHugo. Mathematics in Markdown . https://gohugo.io/content-management/mathematics/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n科学空间. https://spaces.ac.cn/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-10-13T00:00:00Z","permalink":"https://ovideros.site/p/hugo_footnote/","title":"魔改hugo footnote与数学公式，实现漂亮的引用"},{"content":" 该列表旨在分享一些有意思的CS Wikis。不求全，但求精。\n条目要求：\n原创，无广告 可以是wiki界面，github界面等 内容足够有趣 因为本人视野有限，故下面的列表肯定不全。欢迎各位直接在评论区进行补充！\n通用 AC Wiki CS 自学指南 计算机保研指南 CS Plan HackWay技术学习路线 AI Tour 0xFFFF Wiki awesome-cs-tutorial 一些大学维护的 wikis 上海交通大学生存手册 Linux 101 Linux 201 SAST skill docs THU-CST-Cracker 浙江大学课程攻略共享计划 科研入门 GAMES003 Learning Research PKU-DAIR Starter Guide RHOS 科研手册 Embodied-AI-Guide Awesome MLLMs 学科/竞赛相关 OI Wiki CTF Wiki ","date":"2025-08-17T00:00:00Z","permalink":"https://ovideros.site/p/awesome_cs_wikis/","title":"Awesome CS Wikis"}]